<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QueuedMessageWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Core</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.mio</a> &gt; <span class="el_source">QueuedMessageWriter.java</span></div><h1>QueuedMessageWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-2016 Providence Authors
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package net.morimekta.providence.mio;

import net.morimekta.providence.PMessage;
import net.morimekta.providence.PServiceCall;
import net.morimekta.providence.descriptor.PField;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * A queued message writer that takes in messages onto a queue, and let
 * a single thread handle all the writes to the contained writer. This
 * writer is thread safe, and should be much faster than having multiple
 * threads fight over the file IO.
 * &lt;p&gt;
 * Note that the writer will continue to accept messages after it has been
 * closed.
 */
public class QueuedMessageWriter implements MessageWriter {
<span class="fc" id="L49">    private static final Logger LOGGER = LoggerFactory.getLogger(QueuedMessageWriter.class);</span>
    private static final int    DEFAULT_MAX_QUEUE_LEN = 65536;

    private final Queue&lt;PMessage&gt; messageQueue;
    private final Queue&lt;PServiceCall&gt; callQueue;
    private final ExecutorService executor;
    private final MessageWriter   writer;
    private final int maxQueueLength;

    /**
     * Create a queued message writer.
     *
     * @param writer The message writer to write to.
     */
    public QueuedMessageWriter(MessageWriter writer) {
<span class="fc" id="L64">        this(writer, Executors.newSingleThreadExecutor(</span>
                new ThreadFactoryBuilder()
<span class="fc" id="L66">                        .setDaemon(true)</span>
<span class="fc" id="L67">                        .setNameFormat(&quot;providence-queued-writer&quot;)</span>
<span class="fc" id="L68">                        .build()));</span>
<span class="fc" id="L69">    }</span>

    /**
     * Create a queued message writer using the given executor service.
     * Note that the executor service will be shut down with the message queue.
     *
     * @param writer The message writer to write to.
     * @param executor The executor service running the write loop thread.
     */
    public QueuedMessageWriter(MessageWriter writer,
                               ExecutorService executor) {
<span class="fc" id="L80">        this(writer, executor, DEFAULT_MAX_QUEUE_LEN);</span>
<span class="fc" id="L81">    }</span>

    /**
     * Create a queued message writer using the given executor service.
     * Note that the executor service will be shut down with the message queue.
     *
     * @param writer The message writer to write to.
     * @param executor The executor service running the write loop thread.
     * @param maxQueueLength The max queue length. If 0 or less, no limit is enforced.
     *                       Default is 65536 (64k).
     */
    public QueuedMessageWriter(MessageWriter writer,
                               ExecutorService executor,
<span class="fc" id="L94">                               int maxQueueLength) {</span>
<span class="fc" id="L95">        this.writer = writer;</span>
<span class="fc" id="L96">        this.executor = executor;</span>
<span class="fc" id="L97">        this.maxQueueLength = maxQueueLength;</span>
<span class="fc" id="L98">        this.messageQueue = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L99">        this.callQueue = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L100">        this.executor.submit(this::writeLoop);</span>
<span class="fc" id="L101">    }</span>

    /**
     * @return The current size of the in-memory queue.
     */
    public int size() {
<span class="fc" id="L107">        return callQueue.size() + messageQueue.size();</span>
    }

    @Override
    public &lt;Message extends PMessage&lt;Message, Field&gt;, Field extends PField&gt;
    int write(Message message) throws IOException {
<span class="pc bpc" id="L113" title="2 of 4 branches missed.">        if (maxQueueLength &lt;= 0 || size() &lt; maxQueueLength) {</span>
<span class="fc" id="L114">            messageQueue.offer(message);</span>
<span class="fc" id="L115">            return 1;</span>
        }
<span class="nc" id="L117">        return 0;</span>
    }

    @Override
    public &lt;Message extends PMessage&lt;Message, Field&gt;, Field extends PField&gt;
    int write(PServiceCall&lt;Message, Field&gt; call) throws IOException {
<span class="pc bpc" id="L123" title="2 of 4 branches missed.">        if (maxQueueLength &lt;= 0 || size() &lt; maxQueueLength) {</span>
<span class="fc" id="L124">            callQueue.offer(call);</span>
<span class="fc" id="L125">            return 1;</span>
        }
<span class="nc" id="L127">        return 0;</span>
    }

    @Override
    public int separator() throws IOException {
<span class="fc" id="L132">        return 0;</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void close() throws IOException {
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (!executor.isShutdown()) {</span>
            try {
<span class="fc" id="L140">                executor.shutdown();</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">                if (!executor.awaitTermination(1000L, TimeUnit.MILLISECONDS)) {</span>
<span class="fc" id="L142">                    executor.shutdownNow();</span>
                }
<span class="fc" id="L144">            } catch (InterruptedException e) {</span>
<span class="fc" id="L145">                LOGGER.error(&quot;Interrupted while stopping writer loop thread&quot;, e);</span>
<span class="fc" id="L146">                throw new RuntimeException(e.getMessage(), e);</span>
            } finally {
<span class="fc" id="L148">                try {</span>
<span class="pc bpc" id="L149" title="1 of 4 branches missed.">                    while (messageQueue.size() &gt; 0) {</span>
<span class="pc" id="L150">                        writer.write(messageQueue.poll());</span>
<span class="pc" id="L151">                        writer.separator();</span>
                    }
<span class="pc bpc" id="L153" title="2 of 4 branches missed.">                    while (callQueue.size() &gt; 0) {</span>
<span class="pc" id="L154">                        writer.write(callQueue.poll());</span>
<span class="pc" id="L155">                        writer.separator();</span>
                    }
<span class="pc" id="L157">                } catch (IOException e) {</span>
<span class="pc" id="L158">                    LOGGER.error(&quot;Unable to write messages on close&quot;, e);</span>
<span class="pc" id="L159">                }</span>
<span class="fc" id="L160">                writer.close();</span>
<span class="fc" id="L161">            }</span>
        }
<span class="fc" id="L163">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private void writeLoop() {
        try {
<span class="fc" id="L168">            long failDelay = 137L;</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">            while (!executor.isShutdown()) {</span>
                try {
<span class="fc bfc" id="L171" title="All 2 branches covered.">                    while (messageQueue.size() &gt; 0) {</span>
<span class="fc" id="L172">                        writer.write(messageQueue.poll());</span>
<span class="fc" id="L173">                        failDelay = 137L;</span>
                    }
<span class="fc bfc" id="L175" title="All 2 branches covered.">                    while (callQueue.size() &gt; 0) {</span>
<span class="fc" id="L176">                        writer.write(callQueue.poll());</span>
<span class="fc" id="L177">                        failDelay = 137L;</span>
                    }
<span class="fc" id="L179">                    sleep(3L);  // 3ms should be enough to do actual work.</span>
                    // This is a very tight loop, so should be expensive to
                    // to have a short sleep time.
<span class="fc" id="L182">                } catch (IOException e) {</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">                    if (failDelay &gt;= 10_000) {</span>
<span class="nc" id="L184">                        LOGGER.error(&quot;Unable to write message, sleeping {}s&quot;,</span>
<span class="nc" id="L185">                                     (failDelay / 1000), e);</span>
                    } else {
<span class="fc" id="L187">                        LOGGER.error(&quot;Unable to write message, sleeping {}ms&quot;,</span>
<span class="fc" id="L188">                                     failDelay, e);</span>
                    }

                    // Continue but with longer sleep on errors.
                    try {
<span class="fc" id="L193">                        sleep(failDelay);</span>
                    } finally {
<span class="pc" id="L195">                        failDelay = Math.min(</span>
<span class="pc" id="L196">                                TimeUnit.MINUTES.toMillis(10),</span>
                                // add 2/3 to the time for each consecutive failure.
                                (long) (failDelay * 1.66666667));
<span class="fc" id="L199">                    }</span>
<span class="fc" id="L200">                }</span>
            }
<span class="nc" id="L202">        } catch (InterruptedException ignore) {</span>
            // thread is interrupted, just stop. Not tested.
<span class="nc" id="L204">            Thread.currentThread().interrupt();</span>
<span class="fc" id="L205">        }</span>
<span class="fc" id="L206">    }</span>

    @VisibleForTesting
    protected void sleep(long ms) throws InterruptedException {
<span class="fc" id="L210">        Thread.sleep(ms);</span>
<span class="fc" id="L211">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>