<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonSerializer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Core</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.serializer</a> &gt; <span class="el_source">JsonSerializer.java</span></div><h1>JsonSerializer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-2016 Providence Authors
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package net.morimekta.providence.serializer;

import net.morimekta.providence.PApplicationException;
import net.morimekta.providence.PApplicationExceptionType;
import net.morimekta.providence.PEnumBuilder;
import net.morimekta.providence.PEnumValue;
import net.morimekta.providence.PMessage;
import net.morimekta.providence.PMessageBuilder;
import net.morimekta.providence.PServiceCall;
import net.morimekta.providence.PServiceCallType;
import net.morimekta.providence.PUnion;
import net.morimekta.providence.descriptor.PContainer;
import net.morimekta.providence.descriptor.PDescriptor;
import net.morimekta.providence.descriptor.PEnumDescriptor;
import net.morimekta.providence.descriptor.PField;
import net.morimekta.providence.descriptor.PList;
import net.morimekta.providence.descriptor.PMap;
import net.morimekta.providence.descriptor.PMessageDescriptor;
import net.morimekta.providence.descriptor.PService;
import net.morimekta.providence.descriptor.PServiceMethod;
import net.morimekta.providence.descriptor.PSet;
import net.morimekta.providence.serializer.json.JsonCompactible;
import net.morimekta.providence.serializer.json.JsonCompactibleDescriptor;
import net.morimekta.util.Binary;
import net.morimekta.util.Strings;
import net.morimekta.util.io.CountingOutputStream;
import net.morimekta.util.json.JsonException;
import net.morimekta.util.json.JsonToken;
import net.morimekta.util.json.JsonTokenizer;
import net.morimekta.util.json.JsonWriter;
import net.morimekta.util.json.PrettyJsonWriter;

import javax.annotation.Nonnull;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.Map;

import static java.util.Objects.requireNonNull;

/**
 * Compact JSON serializer. This uses the most compact type-safe JSON format
 * allowable. There are two optional variants switching the struct field ID
 * between numeric ID and field name.
 * &lt;p&gt;
 * There is also the strict mode. If strict is OFF:
 * - Unknown enum values will be ignored (as field missing).
 * - Message validity will be ignored.
 * If strict more is ON:
 * - Unknown enum values will fail deserialization.
 * - Message invalidity will fail deserialization.
 * &lt;p&gt;
 * Format is like this:
 * &lt;pre&gt;
 * {
 *     &quot;id&quot;:value,
 *     &quot;structId&quot;:{ ... },
 *     &quot;listId&quot;:[value1,value2],
 *     &quot;mapId&quot;:{&quot;id1&quot;:value1,&quot;id2&quot;:value2}
 * }
 * &lt;/pre&gt;
 * But without formatting spaces. The formatted JSON can be read normally.
 * Binary fields are base64 encoded.
 * &lt;p&gt;
 * This format supports 'compact' struct formatting. A compact struct is
 * formatted as a list with fields in order from 1 to N. E.g.:
 * &lt;pre&gt;
 * [&quot;tag&quot;,5,6.45]
 * &lt;/pre&gt;
 * is equivalent to:
 * &lt;pre&gt;
 * {&quot;1&quot;:&quot;tag&quot;,&quot;2&quot;:5,&quot;3&quot;:6.45}
 * &lt;/pre&gt;
 */
public class JsonSerializer extends Serializer {
    public static final String MEDIA_TYPE      = &quot;application/vnd.morimekta.providence.json&quot;;
    public static final String JSON_MEDIA_TYPE = &quot;application/json&quot;;

    public JsonSerializer() {
<span class="fc" id="L104">        this(DEFAULT_STRICT, false, IdType.ID, IdType.ID);</span>
<span class="fc" id="L105">    }</span>

    public JsonSerializer(boolean strict) {
<span class="fc" id="L108">        this(strict, false, IdType.ID, IdType.ID);</span>
<span class="fc" id="L109">    }</span>

    public JsonSerializer pretty() {
<span class="fc" id="L112">        return new JsonSerializer(readStrict, true, IdType.NAME, IdType.NAME);</span>
    }

    public JsonSerializer named() {
<span class="fc" id="L116">        return withNamedEnums().withNamedFields();</span>
    }

    public JsonSerializer withNamedFields() {
<span class="fc" id="L120">        return new JsonSerializer(readStrict, prettyPrint, IdType.NAME, enumValueType);</span>
    }

    public JsonSerializer withNamedEnums() {
<span class="fc" id="L124">        return new JsonSerializer(readStrict, prettyPrint, fieldIdType, IdType.NAME);</span>
    }

    @Override
    public &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt; int serialize(@Nonnull OutputStream output, @Nonnull T message) throws IOException {
<span class="fc" id="L129">        CountingOutputStream counter = new CountingOutputStream(output);</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        JsonWriter jsonWriter = prettyPrint ? new PrettyJsonWriter(counter) : new JsonWriter(counter);</span>
<span class="fc" id="L131">        appendMessage(jsonWriter, message);</span>
<span class="fc" id="L132">        jsonWriter.flush();</span>
<span class="fc" id="L133">        counter.flush();</span>
<span class="fc" id="L134">        return counter.getByteCount();</span>
    }

    @Override
    public &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt; int serialize(@Nonnull OutputStream output, @Nonnull
            PServiceCall&lt;T, F&gt; call)
            throws IOException {
<span class="fc" id="L141">        CountingOutputStream counter = new CountingOutputStream(output);</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        JsonWriter jsonWriter = prettyPrint ? new PrettyJsonWriter(counter) : new JsonWriter(counter);</span>

<span class="fc" id="L144">        jsonWriter.array().value(call.getMethod());</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        if (enumValueType == IdType.ID) {</span>
<span class="fc" id="L146">            jsonWriter.value(call.getType().asInteger());</span>
        } else {
<span class="fc" id="L148">            jsonWriter.valueUnescaped(call.getType().asString());</span>
        }
<span class="fc" id="L150">        jsonWriter.value(call.getSequence());</span>

<span class="fc" id="L152">        appendMessage(jsonWriter, call.getMessage());</span>

<span class="fc" id="L154">        jsonWriter.endArray().flush();</span>
<span class="fc" id="L155">        counter.flush();</span>
<span class="fc" id="L156">        return counter.getByteCount();</span>

    }

    @Nonnull
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T extends PMessage&lt;T, TF&gt;, TF extends PField&gt; T deserialize(
            @Nonnull InputStream input, @Nonnull PMessageDescriptor&lt;T, TF&gt; type) throws IOException {
        try {
<span class="fc bfc" id="L166" title="All 2 branches covered.">            JsonTokenizer tokenizer = new JsonTokenizer(input, prettyPrint ? PRETTY_READ_BUFFER_SIZE : DEFAULT_READ_BUFFER_SIZE);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">            if (!tokenizer.hasNext()) {</span>
<span class="fc" id="L168">                throw new SerializerException(&quot;Empty json body&quot;);</span>
            }
<span class="fc" id="L170">            return requireNonNull((T) parseTypedValue(tokenizer.next(), tokenizer, type, false));</span>
<span class="fc" id="L171">        } catch (JsonException e) {</span>
<span class="fc" id="L172">            throw new JsonSerializerException(e);</span>
        }
    }

    @Nonnull
    @Override
    public &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt; PServiceCall&lt;T, F&gt; deserialize(@Nonnull InputStream input, @Nonnull
            PService service)
            throws IOException {
<span class="fc bfc" id="L181" title="All 2 branches covered.">        JsonTokenizer tokenizer = new JsonTokenizer(input, prettyPrint ? PRETTY_READ_BUFFER_SIZE : DEFAULT_READ_BUFFER_SIZE);</span>
<span class="fc" id="L182">        return parseServiceCall(tokenizer, service);</span>
    }

    @Override
    public boolean binaryProtocol() {
<span class="fc" id="L187">        return false;</span>
    }

    @Nonnull
    @Override
    public String mediaType() {
        // Pretend &quot;application/json&quot; as media type if named fields are used.
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (fieldIdType == IdType.NAME) {</span>
<span class="fc" id="L195">            return JSON_MEDIA_TYPE;</span>
        }
<span class="fc" id="L197">        return MEDIA_TYPE;</span>
    }

    // ------------------- PRIVATE ONLY ------------------

<span class="fc" id="L202">    private JsonSerializer(boolean readStrict, boolean prettyPrint, IdType fieldIdType, IdType enumValueType) {</span>
<span class="fc" id="L203">        this.readStrict = readStrict;</span>
<span class="fc" id="L204">        this.prettyPrint = prettyPrint;</span>
<span class="fc" id="L205">        this.fieldIdType = fieldIdType;</span>
<span class="fc" id="L206">        this.enumValueType = enumValueType;</span>
<span class="fc" id="L207">    }</span>

<span class="pc" id="L209">    private enum IdType {</span>
        // print field or enums as numeric IDs and values.
<span class="fc" id="L211">        ID,</span>
        // print field or enums as field name and enum name.
<span class="fc" id="L213">        NAME</span>
    }

    private static final int PRETTY_READ_BUFFER_SIZE  = 1 &lt;&lt; 10;  //  1024 chars.
    private static final int DEFAULT_READ_BUFFER_SIZE = 1 &lt;&lt; 15;  // 32768 chars --&gt; 64kb

    private final boolean readStrict;
    private final IdType  fieldIdType;
    private final IdType  enumValueType;
    private final boolean prettyPrint;

    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt; PServiceCall&lt;T, F&gt; parseServiceCall(JsonTokenizer tokenizer, PService service)
            throws IOException {
<span class="fc" id="L227">        PServiceCallType type = null;</span>
<span class="fc" id="L228">        String methodName = null;</span>
<span class="fc" id="L229">        int sequence = 0;</span>
        try {
<span class="fc" id="L231">            tokenizer.expectSymbol(&quot;service call start&quot;, JsonToken.kListStart);</span>

<span class="fc" id="L233">            methodName = tokenizer.expectString(&quot;method name&quot;)</span>
<span class="fc" id="L234">                                  .rawJsonLiteral();</span>

<span class="fc" id="L236">            tokenizer.expectSymbol(&quot;entry sep&quot;, JsonToken.kListSep);</span>

<span class="fc" id="L238">            JsonToken callTypeToken = tokenizer.expect(&quot;call type&quot;);</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">            if (callTypeToken.isInteger()) {</span>
<span class="fc" id="L240">                int typeKey = callTypeToken.byteValue();</span>
<span class="fc" id="L241">                type = PServiceCallType.findById(typeKey);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">                if (type == null) {</span>
<span class="fc" id="L243">                    throw new SerializerException(&quot;Service call type &quot; + typeKey + &quot; is not valid&quot;)</span>
<span class="fc" id="L244">                            .setExceptionType(PApplicationExceptionType.INVALID_MESSAGE_TYPE);</span>
                }
<span class="fc bfc" id="L246" title="All 2 branches covered.">            } else if (callTypeToken.isLiteral()) {</span>
<span class="fc" id="L247">                String typeName = callTypeToken.rawJsonLiteral();</span>
<span class="fc" id="L248">                type = PServiceCallType.findByName(typeName);</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                if (type == null) {</span>
<span class="fc" id="L250">                    throw new SerializerException(&quot;Service call type \&quot;&quot; + Strings.escape(typeName) + &quot;\&quot; is not valid&quot;)</span>
<span class="fc" id="L251">                            .setExceptionType(PApplicationExceptionType.INVALID_MESSAGE_TYPE);</span>
                }
<span class="fc" id="L253">            } else {</span>
<span class="fc" id="L254">                throw new SerializerException(&quot;Invalid service call type token &quot; + callTypeToken.asString())</span>
<span class="fc" id="L255">                        .setExceptionType(PApplicationExceptionType.INVALID_MESSAGE_TYPE);</span>
            }

<span class="fc" id="L258">            tokenizer.expectSymbol(&quot;entry sep&quot;, JsonToken.kListSep);</span>

<span class="fc" id="L260">            sequence = tokenizer.expectNumber(&quot;Service call sequence&quot;)</span>
<span class="fc" id="L261">                                .intValue();</span>

<span class="fc" id="L263">            tokenizer.expectSymbol(&quot;entry sep&quot;, JsonToken.kListSep);</span>

<span class="fc bfc" id="L265" title="All 2 branches covered.">            if (type == PServiceCallType.EXCEPTION) {</span>
<span class="fc" id="L266">                PApplicationException ex = (PApplicationException) parseTypedValue(tokenizer.expect(&quot;Message start&quot;),</span>
                                                                                   tokenizer,
                                                                                   PApplicationException.kDescriptor,
                                                                                   false);

<span class="fc" id="L271">                tokenizer.expectSymbol(&quot;service call end&quot;, JsonToken.kListEnd);</span>

<span class="fc" id="L273">                return (PServiceCall&lt;T, F&gt;) new PServiceCall&lt;&gt;(methodName, type, sequence, ex);</span>
            }

<span class="fc" id="L276">            PServiceMethod method = service.getMethod(methodName);</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">            if (method == null) {</span>
<span class="nc" id="L278">                throw new SerializerException(&quot;No such method &quot; + methodName + &quot; on &quot; + service.getQualifiedName())</span>
<span class="nc" id="L279">                        .setExceptionType(PApplicationExceptionType.UNKNOWN_METHOD);</span>
            }

            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc bfc" id="L283" title="All 2 branches covered.">            PMessageDescriptor&lt;T, F&gt; descriptor = isRequestCallType(type) ? method.getRequestType() : method.getResponseType();</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">            if (descriptor == null) {</span>
<span class="fc" id="L285">                throw new SerializerException(&quot;No %s type for %s.%s()&quot;,</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">                                              isRequestCallType(type) ? &quot;request&quot; : &quot;response&quot;,</span>
<span class="fc" id="L287">                                              service.getQualifiedName(), methodName)</span>
<span class="fc" id="L288">                        .setExceptionType(PApplicationExceptionType.UNKNOWN_METHOD);</span>
            }
<span class="fc" id="L290">            T message = (T) parseTypedValue(tokenizer.expect(&quot;message start&quot;), tokenizer, descriptor, false);</span>

<span class="fc" id="L292">            tokenizer.expectSymbol(&quot;service call end&quot;, JsonToken.kListEnd);</span>

<span class="fc" id="L294">            return new PServiceCall&lt;&gt;(methodName, type, sequence, message);</span>
<span class="fc" id="L295">        } catch (SerializerException se) {</span>
<span class="fc" id="L296">            throw new SerializerException(se)</span>
<span class="fc" id="L297">                    .setMethodName(methodName)</span>
<span class="fc" id="L298">                    .setCallType(type)</span>
<span class="fc" id="L299">                    .setSequenceNo(sequence);</span>
<span class="fc" id="L300">        } catch (JsonException je) {</span>
<span class="fc" id="L301">            throw new JsonSerializerException(je)</span>
<span class="fc" id="L302">                    .setMethodName(methodName)</span>
<span class="fc" id="L303">                    .setCallType(type)</span>
<span class="fc" id="L304">                    .setSequenceNo(sequence);</span>
        }
    }

    private &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt; T parseMessage(JsonTokenizer tokenizer, PMessageDescriptor&lt;T, F&gt; type)
            throws JsonException, IOException {
<span class="fc" id="L310">        PMessageBuilder&lt;T, F&gt; builder = type.builder();</span>

<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (tokenizer.peek(&quot;message end or key&quot;).isSymbol(JsonToken.kMapEnd)) {</span>
<span class="fc" id="L313">            tokenizer.next();</span>
        } else {
<span class="fc" id="L315">            char sep = JsonToken.kMapStart;</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">            while (sep != JsonToken.kMapEnd) {</span>
<span class="fc" id="L317">                JsonToken token = tokenizer.expectString(&quot;field spec&quot;);</span>
<span class="fc" id="L318">                String key = token.rawJsonLiteral();</span>
                PField field;
<span class="fc bfc" id="L320" title="All 2 branches covered.">                if (Strings.isInteger(key)) {</span>
<span class="fc" id="L321">                    field = type.findFieldById(Integer.parseInt(key));</span>
                } else {
<span class="fc" id="L323">                    field = type.findFieldByName(key);</span>
                }
<span class="fc" id="L325">                tokenizer.expectSymbol(&quot;field KV sep&quot;, JsonToken.kKeyValSep);</span>

<span class="fc bfc" id="L327" title="All 2 branches covered.">                if (field != null) {</span>
<span class="fc" id="L328">                    Object value = parseTypedValue(tokenizer.expect(&quot;field value&quot;), tokenizer, field.getDescriptor(), true);</span>
<span class="fc" id="L329">                    builder.set(field.getId(), value);</span>
<span class="fc" id="L330">                } else {</span>
<span class="fc" id="L331">                    consume(tokenizer.expect(&quot;field value&quot;), tokenizer);</span>
                }

<span class="fc" id="L334">                sep = tokenizer.expectSymbol(&quot;message end or sep&quot;, JsonToken.kMapEnd, JsonToken.kListSep);</span>
<span class="fc" id="L335">            }</span>
        }

<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (readStrict) {</span>
            try {
<span class="fc" id="L340">                builder.validate();</span>
<span class="fc" id="L341">            } catch (IllegalStateException e) {</span>
<span class="fc" id="L342">                throw new SerializerException(e, e.getMessage());</span>
<span class="fc" id="L343">            }</span>
        }

<span class="fc" id="L346">        return builder.build();</span>
    }

    private &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt; T parseCompactMessage(JsonTokenizer tokenizer, PMessageDescriptor&lt;T, F&gt; type)
            throws IOException, JsonException {
<span class="fc" id="L351">        PMessageBuilder&lt;T, F&gt; builder = type.builder();</span>
        // compact message are not allowed to be empty.

<span class="fc" id="L354">        int i = 0;</span>
<span class="fc" id="L355">        char sep = JsonToken.kListStart;</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">        while (sep != JsonToken.kListEnd) {</span>
<span class="fc" id="L357">            PField field = type.findFieldById(++i);</span>

<span class="pc bpc" id="L359" title="1 of 2 branches missed.">            if (field != null) {</span>
<span class="fc" id="L360">                Object value = parseTypedValue(tokenizer.expect(&quot;field value&quot;), tokenizer, field.getDescriptor(), true);</span>
<span class="fc" id="L361">                builder.set(i, value);</span>
<span class="fc" id="L362">            } else {</span>
<span class="nc" id="L363">                consume(tokenizer.expect(&quot;compact field value&quot;), tokenizer);</span>
            }

<span class="fc" id="L366">            sep = tokenizer.expectSymbol(&quot;compact entry sep&quot;, JsonToken.kListEnd, JsonToken.kListSep);</span>
<span class="fc" id="L367">        }</span>

<span class="fc bfc" id="L369" title="All 2 branches covered.">        if (readStrict) {</span>
            try {
<span class="fc" id="L371">                builder.validate();</span>
<span class="nc" id="L372">            } catch (IllegalStateException e) {</span>
<span class="nc" id="L373">                throw new SerializerException(e, e.getMessage());</span>
<span class="fc" id="L374">            }</span>
        }

<span class="fc" id="L377">        return builder.build();</span>
    }

    private void consume(JsonToken token, JsonTokenizer tokenizer) throws IOException, JsonException {
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (token.isSymbol()) {</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">            if (token.isSymbol(JsonToken.kListStart)) {</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">                if (tokenizer.peek(&quot;lists end or value&quot;).isSymbol(JsonToken.kListEnd)) {</span>
<span class="fc" id="L384">                    tokenizer.next();</span>
                } else {
<span class="fc" id="L386">                    char sep = JsonToken.kListStart;</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">                    while (sep != JsonToken.kListEnd) {</span>
<span class="fc" id="L388">                        consume(tokenizer.expect(&quot;list item&quot;), tokenizer);</span>
<span class="fc" id="L389">                        sep = tokenizer.expectSymbol(&quot;list sep&quot;, JsonToken.kListEnd, JsonToken.kListSep);</span>
                    }
<span class="fc" id="L391">                }</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">            } else if (token.isSymbol(JsonToken.kMapStart)) {</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">                if (tokenizer.peek(&quot;map end or key&quot;).isSymbol(JsonToken.kMapEnd)) {</span>
<span class="fc" id="L394">                    tokenizer.next();</span>
                } else {
<span class="fc" id="L396">                    char sep = JsonToken.kMapStart;</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">                    while (sep != JsonToken.kMapEnd) {</span>
<span class="fc" id="L398">                        tokenizer.expectString(&quot;map key&quot;);</span>
<span class="fc" id="L399">                        tokenizer.expectSymbol(&quot;map KV sep&quot;, JsonToken.kKeyValSep);</span>
<span class="fc" id="L400">                        consume(tokenizer.expect(&quot;entry value&quot;), tokenizer);</span>
<span class="fc" id="L401">                        sep = tokenizer.expectSymbol(&quot;map end or sep&quot;, JsonToken.kMapEnd, JsonToken.kListSep);</span>
                    }
                }
            }
        }
        // Otherwise it is a simple value. No need to consume.
<span class="fc" id="L407">    }</span>

    private Object parseTypedValue(JsonToken token, JsonTokenizer tokenizer, PDescriptor t, boolean allowNull)
            throws IOException, JsonException {
<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (token.isNull()) {</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">            if (!allowNull) {</span>
<span class="fc" id="L413">                throw new SerializerException(&quot;Null value as body.&quot;);</span>
            }
<span class="nc" id="L415">            return null;</span>
        }

<span class="pc bpc" id="L418" title="1 of 15 branches missed.">        switch (t.getType()) {</span>
            case VOID: {
<span class="fc bfc" id="L420" title="All 2 branches covered.">                if (token.isBoolean()) {</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">                    return token.booleanValue() ? Boolean.TRUE : null;</span>
                }
<span class="fc" id="L423">                throw new SerializerException(&quot;Not a void token value: '&quot; + token.asString() + &quot;'&quot;);</span>
            }
            case BOOL:
<span class="fc bfc" id="L426" title="All 2 branches covered.">                if (token.isBoolean()) {</span>
<span class="fc" id="L427">                    return token.booleanValue();</span>
                }
<span class="fc" id="L429">                throw new SerializerException(&quot;No boolean value for token: '&quot; + token.asString() + &quot;'&quot;);</span>
            case BYTE:
<span class="fc bfc" id="L431" title="All 2 branches covered.">                if (token.isInteger()) {</span>
<span class="fc" id="L432">                    return token.byteValue();</span>
                }
<span class="fc" id="L434">                throw new SerializerException(&quot;Not a valid byte value: '&quot; + token.asString() + &quot;'&quot;);</span>
            case I16:
<span class="fc bfc" id="L436" title="All 2 branches covered.">                if (token.isInteger()) {</span>
<span class="fc" id="L437">                    return token.shortValue();</span>
                }
<span class="fc" id="L439">                throw new SerializerException(&quot;Not a valid short value: '&quot; + token.asString() + &quot;'&quot;);</span>
            case I32:
<span class="fc bfc" id="L441" title="All 2 branches covered.">                if (token.isInteger()) {</span>
<span class="fc" id="L442">                    return token.intValue();</span>
                }
<span class="fc" id="L444">                throw new SerializerException(&quot;Not a valid int value: '&quot; + token.asString() + &quot;'&quot;);</span>
            case I64:
<span class="fc bfc" id="L446" title="All 2 branches covered.">                if (token.isInteger()) {</span>
<span class="fc" id="L447">                    return token.longValue();</span>
                }
<span class="fc" id="L449">                throw new SerializerException(&quot;Not a valid long value: '&quot; + token.asString() + &quot;'&quot;);</span>
            case DOUBLE:
<span class="fc bfc" id="L451" title="All 2 branches covered.">                if (token.isNumber()) {</span>
<span class="fc" id="L452">                    return token.doubleValue();</span>
                }
<span class="fc" id="L454">                throw new SerializerException(&quot;Not a valid double value: '&quot; + token.asString() + &quot;'&quot;);</span>
            case STRING:
<span class="fc bfc" id="L456" title="All 2 branches covered.">                if (token.isLiteral()) {</span>
<span class="fc" id="L457">                    return token.decodeJsonLiteral();</span>
                }
<span class="fc" id="L459">                throw new SerializerException(&quot;Not a valid string value: '&quot; + token.asString() + &quot;'&quot;);</span>
            case BINARY:
<span class="fc bfc" id="L461" title="All 2 branches covered.">                if (token.isLiteral()) {</span>
                    try {
<span class="fc" id="L463">                        return Binary.fromBase64(token.rawJsonLiteral());</span>
<span class="fc" id="L464">                    } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L465">                        throw new SerializerException(e, &quot;Unable to parse Base64 data: &quot; + token.asString());</span>
                    }
                }
<span class="fc" id="L468">                throw new SerializerException(&quot;Not a valid binary value: &quot; + token.asString());</span>
            case ENUM:
<span class="fc" id="L470">                PEnumBuilder&lt;?&gt; eb = ((PEnumDescriptor&lt;?&gt;) t).builder();</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">                if (token.isInteger()) {</span>
<span class="fc" id="L472">                    eb.setById(token.intValue());</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">                } else if (token.isLiteral()) {</span>
<span class="fc" id="L474">                    eb.setByName(token.rawJsonLiteral());</span>
                } else {
<span class="fc" id="L476">                    throw new SerializerException(token.asString() + &quot; is not a enum value type&quot;);</span>
                }
<span class="fc bfc" id="L478" title="All 4 branches covered.">                if (!(allowNull || eb.valid())) {</span>
<span class="fc" id="L479">                    throw new SerializerException(token.asString() + &quot; is not a known enum value for &quot; + t.getQualifiedName());</span>
                }
<span class="fc" id="L481">                return eb.build();</span>
            case MESSAGE: {
<span class="fc" id="L483">                PMessageDescriptor&lt;?, ?&gt; st = (PMessageDescriptor&lt;?, ?&gt;) t;</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">                if (token.isSymbol(JsonToken.kMapStart)) {</span>
<span class="fc" id="L485">                    return parseMessage(tokenizer, st);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">                } else if (token.isSymbol(JsonToken.kListStart)) {</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">                    if (isCompactible(st)) {</span>
<span class="fc" id="L488">                        return parseCompactMessage(tokenizer, st);</span>
                    } else {
<span class="fc" id="L490">                        throw new SerializerException(</span>
<span class="fc" id="L491">                                st.getName() + &quot; is not compatible for compact struct notation.&quot;);</span>
                    }
                }
<span class="fc" id="L494">                throw new SerializerException(&quot;expected message start, found: '%s'&quot;, token.asString());</span>
            }
            case MAP: {
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L498">                PMap&lt;Object, Object&gt; mapType = (PMap&lt;Object, Object&gt;) t;</span>
<span class="fc" id="L499">                PDescriptor itemType = mapType.itemDescriptor();</span>
<span class="fc" id="L500">                PDescriptor keyType = mapType.keyDescriptor();</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">                if (!token.isSymbol(JsonToken.kMapStart)) {</span>
<span class="fc" id="L502">                    throw new SerializerException(&quot;Invalid start of map '&quot; + token.asString() + &quot;'&quot;);</span>
                }
<span class="fc" id="L504">                PMap.Builder&lt;Object, Object&gt; map = mapType.builder();</span>

<span class="fc bfc" id="L506" title="All 2 branches covered.">                if (tokenizer.peek(&quot;map end or value&quot;).isSymbol(JsonToken.kMapEnd)) {</span>
<span class="fc" id="L507">                    tokenizer.next();</span>
                } else {
<span class="fc" id="L509">                    char sep = JsonToken.kMapStart;</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">                    while (sep != JsonToken.kMapEnd) {</span>
<span class="fc" id="L511">                        Object key = parseMapKey(tokenizer.expectString(&quot;map key&quot;)</span>
<span class="fc" id="L512">                                                          .decodeJsonLiteral(), keyType);</span>
<span class="fc" id="L513">                        tokenizer.expectSymbol(&quot;map K/V sep&quot;, JsonToken.kKeyValSep);</span>
<span class="fc" id="L514">                        Object value = parseTypedValue(tokenizer.expect(&quot;map value&quot;), tokenizer, itemType, false);</span>
<span class="pc bpc" id="L515" title="2 of 4 branches missed.">                        if (key != null &amp;&amp; value != null) {</span>
                            // In lenient mode, just drop the entire entry if the
                            // key could not be parsed. Should only be the case
                            // for unknown enum values.
                            // -- parseMapKey checked for strictRead mode.
<span class="fc" id="L520">                            map.put(key, value);</span>
                        }
<span class="fc" id="L522">                        sep = tokenizer.expectSymbol(&quot;map end or sep&quot;, JsonToken.kMapEnd, JsonToken.kListSep);</span>
<span class="fc" id="L523">                    }</span>
                }
<span class="fc" id="L525">                return map.build();</span>
            }
            case SET: {
<span class="fc" id="L528">                PDescriptor itemType = ((PSet&lt;?&gt;) t).itemDescriptor();</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">                if (!token.isSymbol(JsonToken.kListStart)) {</span>
<span class="fc" id="L530">                    throw new SerializerException(&quot;Invalid start of set '&quot; + token.asString() + &quot;'&quot;);</span>
                }
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L533">                PSet.Builder&lt;Object&gt; set = ((PSet&lt;Object&gt;) t).builder();</span>

<span class="fc bfc" id="L535" title="All 2 branches covered.">                if (tokenizer.peek(&quot;set end or value&quot;).isSymbol(JsonToken.kListEnd)) {</span>
<span class="fc" id="L536">                    tokenizer.next();</span>
                } else {
<span class="fc" id="L538">                    char sep = JsonToken.kListStart;</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">                    while (sep != JsonToken.kListEnd) {</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">                        Object val = parseTypedValue(tokenizer.expect(&quot;set value&quot;), tokenizer, itemType, !readStrict);</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">                        if (val != null) {</span>
                            // In lenient mode, just drop the entire entry if the
                            // key could not be parsed. Should only be the case
                            // for unknown enum values.
<span class="fc" id="L545">                            set.add(val);</span>
                        }
<span class="fc" id="L547">                        sep = tokenizer.expectSymbol(&quot;set end or sep&quot;, JsonToken.kListSep, JsonToken.kListEnd);</span>
<span class="fc" id="L548">                    }</span>
                }
<span class="fc" id="L550">                return set.build();</span>
            }
            case LIST: {
<span class="fc" id="L553">                PDescriptor itemType = ((PList&lt;?&gt;) t).itemDescriptor();</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">                if (!token.isSymbol(JsonToken.kListStart)) {</span>
<span class="fc" id="L555">                    throw new SerializerException(&quot;Invalid start of list '&quot; + token.asString() + &quot;'&quot;);</span>
                }
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L558">                PList.Builder&lt;Object&gt; list = ((PList&lt;Object&gt;) t).builder();</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">                if (tokenizer.peek(&quot;list end or value&quot;).isSymbol(JsonToken.kListEnd)) {</span>
<span class="fc" id="L560">                    tokenizer.next();</span>
                } else {
<span class="fc" id="L562">                    char sep = JsonToken.kListStart;</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">                    while (sep != JsonToken.kListEnd) {</span>
<span class="fc" id="L564">                        list.add(parseTypedValue(tokenizer.expect(&quot;list value&quot;), tokenizer, itemType, false));</span>
<span class="fc" id="L565">                        sep = tokenizer.expectSymbol(&quot;list end or sep&quot;, JsonToken.kListSep, JsonToken.kListEnd);</span>
                    }
                }
<span class="fc" id="L568">                return list.build();</span>
            }
        }

<span class="nc" id="L572">        throw new SerializerException(&quot;Unhandled item type &quot; + t.getQualifiedName());</span>
    }

    private boolean isCompactible(PMessageDescriptor descriptor) {
<span class="fc bfc" id="L576" title="All 2 branches covered.">        return descriptor instanceof JsonCompactibleDescriptor &amp;&amp;</span>
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">               ((JsonCompactibleDescriptor) descriptor).isJsonCompactible();</span>
    }

    private boolean isCompact(PMessage message) {
<span class="pc bpc" id="L581" title="1 of 4 branches missed.">        return message instanceof JsonCompactible &amp;&amp; ((JsonCompactible) message).jsonCompact();</span>
    }

    private Object parseMapKey(String key, PDescriptor keyType) throws SerializerException {
        try {
<span class="pc bpc" id="L586" title="1 of 11 branches missed.">            switch (keyType.getType()) {</span>
                case BOOL:
<span class="fc bfc" id="L588" title="All 2 branches covered.">                    if (key.equalsIgnoreCase(&quot;true&quot;)) {</span>
<span class="fc" id="L589">                        return Boolean.TRUE;</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">                    } else if (key.equalsIgnoreCase(&quot;false&quot;)) {</span>
<span class="fc" id="L591">                        return Boolean.FALSE;</span>
                    }
<span class="fc" id="L593">                    throw new SerializerException(&quot;Invalid boolean value: \&quot;&quot; + Strings.escape(key) + &quot;\&quot;&quot;);</span>
                case BYTE:
<span class="fc" id="L595">                    return Byte.parseByte(key);</span>
                case I16:
<span class="fc" id="L597">                    return Short.parseShort(key);</span>
                case I32:
<span class="fc" id="L599">                    return Integer.parseInt(key);</span>
                case I64:
<span class="fc" id="L601">                    return Long.parseLong(key);</span>
                case DOUBLE:
                    try {
<span class="fc" id="L604">                        JsonTokenizer tokenizer = new JsonTokenizer(new ByteArrayInputStream(key.getBytes(</span>
                                StandardCharsets.US_ASCII)));
<span class="fc" id="L606">                        JsonToken token = tokenizer.next();</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">                        if (!token.isNumber()) {</span>
<span class="fc" id="L608">                            throw new SerializerException(&quot;Unable to parse double from key \&quot;&quot; + key + &quot;\&quot;&quot;);</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">                        } else if (tokenizer.hasNext()) {</span>
<span class="fc" id="L610">                            throw new SerializerException(&quot;Garbage after double: \&quot;&quot; + key + &quot;\&quot;&quot;);</span>
                        }
<span class="fc" id="L612">                        return token.doubleValue();</span>
<span class="fc" id="L613">                    } catch (SerializerException e) {</span>
<span class="fc" id="L614">                        throw e;</span>
<span class="fc" id="L615">                    } catch (JsonException | IOException e) {</span>
<span class="fc" id="L616">                        throw new SerializerException(e, &quot;Unable to parse double from key \&quot;&quot; + key + &quot;\&quot;&quot;);</span>
                    }
                case STRING:
<span class="fc" id="L619">                    return key;</span>
                case BINARY:
                    try {
<span class="fc" id="L622">                        return Binary.fromBase64(key);</span>
<span class="fc" id="L623">                    } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L624">                        throw new SerializerException(e, &quot;Unable to parse Base64 data&quot;);</span>
                    }
                case ENUM:
<span class="fc" id="L627">                    PEnumBuilder&lt;?&gt; eb = ((PEnumDescriptor&lt;?&gt;) keyType).builder();</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">                    if (Strings.isInteger(key)) {</span>
<span class="fc" id="L629">                        eb.setById(Integer.parseInt(key));</span>
                    } else {
<span class="fc" id="L631">                        eb.setByName(key);</span>
                    }
<span class="pc bpc" id="L633" title="1 of 4 branches missed.">                    if (readStrict &amp;&amp; !eb.valid()) {</span>
<span class="fc" id="L634">                        throw new SerializerException(&quot;\&quot;%s\&quot; is not a known enum value for %s&quot;,</span>
<span class="fc" id="L635">                                                      Strings.escape(key), keyType.getQualifiedName());</span>
                    }
<span class="fc" id="L637">                    return eb.build();</span>
                case MESSAGE:
<span class="fc" id="L639">                    PMessageDescriptor&lt;?, ?&gt; st = (PMessageDescriptor&lt;?, ?&gt;) keyType;</span>
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">                    if (!st.isSimple()) {</span>
<span class="nc" id="L641">                        throw new SerializerException(&quot;Only simple structs can be used as map key. %s is not.&quot;,</span>
<span class="nc" id="L642">                                                      st.getQualifiedName());</span>
                    }
<span class="fc" id="L644">                    ByteArrayInputStream input = new ByteArrayInputStream(key.getBytes(StandardCharsets.UTF_8));</span>
                    try {
<span class="fc" id="L646">                        JsonTokenizer tokenizer = new JsonTokenizer(input);</span>
<span class="fc" id="L647">                        if (JsonToken.kMapStart ==</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">                            tokenizer.expectSymbol(&quot;message start&quot;, JsonToken.kMapStart, JsonToken.kListStart)) {</span>
<span class="nc" id="L649">                            return parseMessage(tokenizer, st);</span>
                        } else {
<span class="fc" id="L651">                            return parseCompactMessage(tokenizer, st);</span>
                        }
<span class="fc" id="L653">                    } catch (JsonException | IOException e) {</span>
<span class="fc" id="L654">                        throw new SerializerException(e, &quot;Error parsing message key: &quot; + e.getMessage());</span>
                    }
                default:
<span class="nc" id="L657">                    throw new SerializerException(&quot;Illegal key type: %s&quot;, keyType.getType());</span>
            }
<span class="fc" id="L659">        } catch (NumberFormatException nfe) {</span>
<span class="fc" id="L660">            throw new SerializerException(nfe, &quot;Unable to parse numeric value %s&quot;, key);</span>
        }
    }

    private void appendMessage(JsonWriter writer, PMessage&lt;?,?&gt; message) throws SerializerException {
<span class="fc" id="L665">        PMessageDescriptor&lt;?, ?&gt; type = message.descriptor();</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">        if (message instanceof PUnion) {</span>
<span class="fc" id="L667">            writer.object();</span>
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">            if (((PUnion) message).unionFieldIsSet()) {</span>
<span class="fc" id="L669">                PField field = ((PUnion) message).unionField();</span>
<span class="fc" id="L670">                Object value = message.get(field.getId());</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">                if (IdType.ID.equals(fieldIdType)) {</span>
<span class="fc" id="L672">                    writer.key(field.getId());</span>
                } else {
<span class="fc" id="L674">                    writer.keyUnescaped(field.getName());</span>
                }
<span class="fc" id="L676">                appendTypedValue(writer, field.getDescriptor(), value);</span>
            }
<span class="fc" id="L678">            writer.endObject();</span>
        } else {
<span class="fc bfc" id="L680" title="All 2 branches covered.">            if (isCompact(message)) {</span>
<span class="fc" id="L681">                writer.array();</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">                for (PField field : type.getFields()) {</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">                    if (message.has(field.getId())) {</span>
<span class="fc" id="L684">                        appendTypedValue(writer, field.getDescriptor(), message.get(field.getId()));</span>
                    } else {
                        break;
                    }
                }
<span class="fc" id="L689">                writer.endArray();</span>
            } else {
<span class="fc" id="L691">                writer.object();</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">                for (PField field : type.getFields()) {</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">                    if (message.has(field.getId())) {</span>
<span class="fc" id="L694">                        Object value = message.get(field.getId());</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">                        if (IdType.ID.equals(fieldIdType)) {</span>
<span class="fc" id="L696">                            writer.key(field.getId());</span>
                        } else {
<span class="fc" id="L698">                            writer.keyUnescaped(field.getName());</span>
                        }
<span class="fc" id="L700">                        appendTypedValue(writer, field.getDescriptor(), value);</span>
                    }
                }
<span class="fc" id="L703">                writer.endObject();</span>
            }
        }
<span class="fc" id="L706">    }</span>

    private void appendTypedValue(JsonWriter writer, PDescriptor type, Object value)
            throws SerializerException {
<span class="fc bfc" id="L710" title="All 5 branches covered.">        switch (type.getType()) {</span>
            case VOID:
<span class="fc" id="L712">                writer.value(true);</span>
<span class="fc" id="L713">                break;</span>
            case MESSAGE:
<span class="fc" id="L715">                PMessage&lt;?,?&gt; message = (PMessage&lt;?,?&gt;) value;</span>
<span class="fc" id="L716">                appendMessage(writer, message);</span>
<span class="fc" id="L717">                break;</span>
            case MAP:
<span class="fc" id="L719">                writer.object();</span>

<span class="fc" id="L721">                PMap&lt;?, ?&gt; mapType = (PMap&lt;?, ?&gt;) type;</span>

<span class="fc" id="L723">                Map&lt;?, ?&gt; map = (Map&lt;?, ?&gt;) value;</span>

<span class="fc bfc" id="L725" title="All 2 branches covered.">                for (Map.Entry&lt;?, ?&gt; entry : map.entrySet()) {</span>
<span class="fc" id="L726">                    appendPrimitiveKey(writer, entry.getKey());</span>
<span class="fc" id="L727">                    appendTypedValue(writer, mapType.itemDescriptor(), entry.getValue());</span>
<span class="fc" id="L728">                }</span>

<span class="fc" id="L730">                writer.endObject();</span>
<span class="fc" id="L731">                break;</span>
            case SET:
            case LIST:
<span class="fc" id="L734">                writer.array();</span>

<span class="fc" id="L736">                PContainer&lt;?&gt; containerType = (PContainer&lt;?&gt;) type;</span>
<span class="fc" id="L737">                Collection&lt;?&gt; collection = (Collection&lt;?&gt;) value;</span>

<span class="fc bfc" id="L739" title="All 2 branches covered.">                for (Object i : collection) {</span>
<span class="fc" id="L740">                    appendTypedValue(writer, containerType.itemDescriptor(), i);</span>
<span class="fc" id="L741">                }</span>

<span class="fc" id="L743">                writer.endArray();</span>
<span class="fc" id="L744">                break;</span>
            default:
<span class="fc" id="L746">                appendPrimitive(writer, value);</span>
                break;
        }
<span class="fc" id="L749">    }</span>

    /**
     * @param writer    The writer to add primitive key to.
     * @param primitive Primitive object to get map key value of.
     */
    private void appendPrimitiveKey(JsonWriter writer, Object primitive) throws SerializerException {
<span class="fc bfc" id="L756" title="All 2 branches covered.">        if (primitive instanceof PEnumValue) {</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">            if (IdType.ID.equals(fieldIdType)) {</span>
<span class="fc" id="L758">                writer.key(((PEnumValue&lt;?&gt;) primitive).asInteger());</span>
            } else {
<span class="fc" id="L760">                writer.keyUnescaped(primitive.toString());</span>
            }
<span class="fc bfc" id="L762" title="All 2 branches covered.">        } else if (primitive instanceof Boolean) {</span>
<span class="fc" id="L763">            writer.key(((Boolean) primitive));</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">        } else if (primitive instanceof Byte) {</span>
<span class="fc" id="L765">            writer.key(((Byte) primitive));</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">        } else if (primitive instanceof Short) {</span>
<span class="fc" id="L767">            writer.key(((Short) primitive));</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">        } else if (primitive instanceof Integer) {</span>
<span class="fc" id="L769">            writer.key(((Integer) primitive));</span>
<span class="fc bfc" id="L770" title="All 2 branches covered.">        } else if (primitive instanceof Long) {</span>
<span class="fc" id="L771">            writer.key(((Long) primitive));</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">        } else if (primitive instanceof Double) {</span>
<span class="fc" id="L773">            writer.key(((Double) primitive));</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">        } else if (primitive instanceof String) {</span>
<span class="fc" id="L775">            writer.key((String) primitive);</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">        } else if (primitive instanceof Binary) {</span>
<span class="fc" id="L777">            writer.key((Binary) primitive);</span>
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">        } else if (primitive instanceof PMessage) {</span>
<span class="fc" id="L779">            PMessage&lt;?,?&gt; message = (PMessage&lt;?,?&gt;) primitive;</span>
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">            if (!message.descriptor().isSimple()) {</span>
<span class="nc" id="L781">                throw new SerializerException(&quot;Only simple messages can be used as map keys. &quot; +</span>
<span class="nc" id="L782">                                              message.descriptor()</span>
<span class="nc" id="L783">                                                     .getQualifiedName() + &quot; is not.&quot;);</span>
            }
<span class="fc" id="L785">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L786">            JsonWriter json = new JsonWriter(baos);</span>
<span class="fc" id="L787">            appendMessage(json, message);</span>
<span class="fc" id="L788">            json.flush();</span>
<span class="fc" id="L789">            writer.key(new String(baos.toByteArray(), StandardCharsets.UTF_8));</span>
<span class="fc" id="L790">        } else {</span>
<span class="nc" id="L791">            throw new SerializerException(&quot;illegal simple type class &quot; + primitive.getClass()</span>
<span class="nc" id="L792">                                                                                  .getSimpleName());</span>
        }
<span class="fc" id="L794">    }</span>

    /**
     * Append a primitive value to json struct.
     *
     * @param writer    The JSON writer.
     * @param primitive The primitive instance.
     */
    private void appendPrimitive(JsonWriter writer, Object primitive) throws SerializerException {
<span class="fc bfc" id="L803" title="All 2 branches covered.">        if (primitive instanceof PEnumValue) {</span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">            if (IdType.ID.equals(enumValueType)) {</span>
<span class="fc" id="L805">                writer.value(((PEnumValue&lt;?&gt;) primitive).asInteger());</span>
            } else {
<span class="fc" id="L807">                writer.valueUnescaped(primitive.toString());</span>
            }
<span class="fc bfc" id="L809" title="All 2 branches covered.">        } else if (primitive instanceof Boolean) {</span>
<span class="fc" id="L810">            writer.value(((Boolean) primitive));</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">        } else if (primitive instanceof Byte) {</span>
<span class="fc" id="L812">            writer.value(((Byte) primitive));</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">        } else if (primitive instanceof Short) {</span>
<span class="fc" id="L814">            writer.value(((Short) primitive));</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">        } else if (primitive instanceof Integer) {</span>
<span class="fc" id="L816">            writer.value(((Integer) primitive));</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">        } else if (primitive instanceof Long) {</span>
<span class="fc" id="L818">            writer.value(((Long) primitive));</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">        } else if (primitive instanceof Double) {</span>
<span class="fc" id="L820">            writer.value(((Double) primitive));</span>
<span class="fc bfc" id="L821" title="All 2 branches covered.">        } else if (primitive instanceof CharSequence) {</span>
<span class="fc" id="L822">            writer.value((String) primitive);</span>
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">        } else if (primitive instanceof Binary) {</span>
<span class="fc" id="L824">            writer.value((Binary) primitive);</span>
        } else {
<span class="nc" id="L826">            throw new SerializerException(&quot;illegal primitive type class &quot; + primitive.getClass()</span>
<span class="nc" id="L827">                                                                                     .getSimpleName());</span>
        }
<span class="fc" id="L829">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>