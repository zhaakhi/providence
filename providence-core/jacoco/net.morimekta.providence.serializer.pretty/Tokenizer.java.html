<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tokenizer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Core</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.serializer.pretty</a> &gt; <span class="el_source">Tokenizer.java</span></div><h1>Tokenizer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-2016 Providence Authors
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package net.morimekta.providence.serializer.pretty;

import net.morimekta.util.Strings;
import net.morimekta.util.io.LineBufferedReader;
import net.morimekta.util.io.Utf8StreamReader;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.CharArrayWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;

/**
 * Simple tokenizer for the pretty serializer that strips away comments based
 * on the &quot;#&quot; (shell) comment character. Each comment lasts until the next
 * newline.
 */
public class Tokenizer extends LineBufferedReader {
    @FunctionalInterface
    public interface TokenValidator {
        boolean validate(Token token);
    }

    public static final int     DEFAULT_BUFFER_SIZE = 1 &lt;&lt; 11; // 2048 chars --&gt; 4kb

    private Token unreadToken;

    /**
     * Create a JSON tokenizer that reads from the input steam. It will only
     * read as far as requested, and no bytes further. It has no checking of
     * whether the document follows the JSON standard, but will only accept
     * JSON formatted tokens.
     *
     * Note that the content is assumed to be separated with newlines, which
     * means that if multiple JSON contents are read from the same stream, they
     * MUST have a separating newline. A single JSON object may still have
     * newlines in it's stream.
     *
     * @param in Input stream to parse from.
     */
    public Tokenizer(InputStream in) {
<span class="fc" id="L63">        this(in, DEFAULT_BUFFER_SIZE);</span>
<span class="fc" id="L64">    }</span>

    /**
     * Create a JSON tokenizer that reads from the input steam. It will only
     * read as far as requested, and no bytes further. It has no checking of
     * whether the document follows the JSON standard, but will only accept
     * JSON formatted tokens.
     *
     * Note that the content is assumed to be separated with newlines, which
     * means that if multiple JSON contents are read from the same stream, they
     * MUST have a separating newline. A single JSON object may still have
     * newlines in it's stream.
     *
     * @param in Input stream to parse from.
     * @param bufferSize The size of the char buffer. Default is 2048 chars
     *                   (4096 bytes).
     */
    public Tokenizer(InputStream in, int bufferSize) {
<span class="fc" id="L82">        this(new Utf8StreamReader(in), bufferSize, false);</span>
<span class="fc" id="L83">    }</span>

    /**
     * Create a tokenizer that will read everything from the input stream and
     * handle it as a single multi-line buffer.
     *
     * @param in Reader of content to parse.
     * @param bufferSize The size of the char buffer. Default is 2048 chars
     *                   (4096 bytes).
     * @param preLoadAll Load all content up front. Handy for config and thrift
     *                   program files.
     */
    public Tokenizer(Reader in, int bufferSize, boolean preLoadAll) {
<span class="fc" id="L96">        super(in, bufferSize, preLoadAll);</span>
        // If the line is longer than 16k, it will not be used in error messages.
<span class="fc" id="L98">        this.unreadToken = null;</span>
<span class="fc" id="L99">    }</span>

    /**
     * Expect a new JSON token on the stream.
     *
     * @param expected Message to add to exception if there are no more JSON
     *                tokens on the stream.
     * @return The next token.
     * @throws IOException If unable to read from stream.
     */
    @Nonnull
    public Token expect(@Nonnull String expected) throws IOException {
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L112">            throw eof(&quot;Expected %s: Got end of file&quot;, expected);</span>
        }
<span class="fc" id="L114">        Token tmp = unreadToken;</span>
<span class="fc" id="L115">        unreadToken = null;</span>
<span class="fc" id="L116">        return tmp;</span>
    }

    /**
     * Expect at a valid token containing anything.
     *
     * @param expected The expectation description.
     * @param validator Validator callback.
     * @return The token.
     * @throws IOException If failed to read a token.
     */
    public Token expect(@Nonnull String expected, @Nonnull TokenValidator validator) throws IOException {
<span class="fc bfc" id="L128" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L129">            throw eof(&quot;Expected %s, got end of file&quot;, expected);</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        } else if (validator.validate(unreadToken)) {</span>
<span class="fc" id="L131">            Token next = unreadToken;</span>
<span class="fc" id="L132">            unreadToken = null;</span>
<span class="fc" id="L133">            return next;</span>
        }
<span class="fc" id="L135">        throw failure(unreadToken, &quot;Expected %s, but got '%s'&quot;, expected, Strings.escape(unreadToken.asString()));</span>
    }

    /**
     * @param expected Message to add to exception if there are no more JSON
     *                 tokens on the stream.
     * @param symbols List of symbol characters to expect.
     * @return The symbol that was encountered.
     * @throws IOException If unable to read from stream.
     */
    public char expectSymbol(@Nonnull String expected, char... symbols) throws IOException {
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        if (symbols.length == 0) {</span>
<span class="nc" id="L147">            throw new IllegalArgumentException(&quot;No symbols to match.&quot;);</span>
        }
<span class="fc bfc" id="L149" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">            if (symbols.length == 1) {</span>
<span class="fc" id="L151">                throw eof(&quot;Expected %s ('%c'), Got end of file&quot;, expected, symbols[0]);</span>
            }
<span class="fc" id="L153">            throw eof(&quot;Expected %s (one of ['%s']): Got end of file&quot;, expected, Strings.joinP(&quot;', '&quot;, symbols));</span>
        } else {
<span class="fc bfc" id="L155" title="All 2 branches covered.">            for (char symbol : symbols) {</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">                if (unreadToken.isSymbol(symbol)) {</span>
<span class="fc" id="L157">                    unreadToken = null;</span>
<span class="fc" id="L158">                    return symbol;</span>
                }
            }

<span class="pc bpc" id="L162" title="1 of 2 branches missed.">            if (symbols.length == 1) {</span>
<span class="nc" id="L163">                throw failure(getLineNo(), getLinePos(), 1, &quot;Expected %s ('%c'): but found '%s'&quot;, expected, symbols[0], unreadToken.asString());</span>
            }

<span class="fc" id="L166">            throw failure(getLineNo(), getLinePos(), 1, &quot;Expected %s (one of ['%s']): but found '%s'&quot;,</span>
                          expected,
<span class="fc" id="L168">                          Strings.joinP(&quot;', '&quot;, symbols),</span>
<span class="fc" id="L169">                          unreadToken.asString());</span>
        }
    }

    public Token expectIdentifier(@Nonnull String message) throws IOException {
<span class="fc" id="L174">        return expect(message, Token::isIdentifier);</span>
    }

    @Nonnull
    public Token expectInteger(String message) throws IOException {
<span class="nc" id="L179">        return expect(message, Token::isInteger);</span>
    }

    @Nonnull
    public Token expectLiteral(String message) throws IOException {
<span class="nc" id="L184">        return expect(message, Token::isStringLiteral);</span>
    }

    /**
     * Whether there is another token on the stream. This will read up until
     * it finds a JSON token, or until the stream ends.
     *
     * @return True if (and only if) there is at least one more token on the
     *         stream.
     * @throws IOException If unable to read from stream.
     */
    public boolean hasNext() throws IOException {
<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (unreadToken == null) {</span>
<span class="fc" id="L197">            unreadToken = next();</span>
        }
<span class="fc bfc" id="L199" title="All 2 branches covered.">        return unreadToken != null;</span>
    }

    /**
     * Read the 'content' of encoded binary. This does not parse the
     * binary, just read out from the buffer the string representing the
     * binary data, as delimited by the requested 'end' char.
     *
     * @param end The char that ends the binary content.
     * @return The string encoded string representation.
     * @throws TokenizerException On illegal content.
     */
    public String readBinary(char end) throws IOException {
<span class="fc" id="L212">        int startOffset = bufferOffset;</span>
<span class="fc" id="L213">        int startLinePos = linePos;</span>
<span class="fc" id="L214">        CharArrayWriter baos = new CharArrayWriter();</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        while (readNextChar()) {</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">            if (lastChar == end) {</span>
<span class="fc" id="L217">                lastChar = 0;</span>
<span class="fc" id="L218">                return baos.toString();</span>
<span class="pc bpc" id="L219" title="4 of 8 branches missed.">            } else if (lastChar == ' ' || lastChar == '\t' || lastChar == '\r' || lastChar == '\n') {</span>
<span class="nc" id="L220">                throw failure(getLineNo(), startLinePos, startOffset, &quot;Illegal char '%s' in binary&quot;, Strings.escape((char) lastChar));</span>
            }
<span class="fc" id="L222">            baos.write(lastChar);</span>
        }
<span class="nc" id="L224">        throw eof(&quot;Unexpected end of file in binary&quot;);</span>
    }

    /**
     * Return the next token or throw an exception. Though it does not consume
     * that token.
     *
     * @return The next token.
     * @throws IOException If unable to read from stream.
     */
    public Token peek() throws IOException {
<span class="nc" id="L235">        hasNext();</span>
<span class="nc" id="L236">        return unreadToken;</span>
    }

    /**
     * Return the next token or throw an exception. Though it does not consume
     * that token.
     *
     * @param message Message to add to exception if there are no more JSON
     *                tokens on the stream.
     * @return The next token.
     * @throws IOException If unable to read from stream.
     */
    @Nonnull
    public Token peek(String message) throws IOException {
<span class="fc bfc" id="L250" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L251">            throw failure(lineNo, linePos + 1, 0, &quot;Expected %s: Got end of file&quot;, message);</span>
        }
<span class="fc" id="L253">        return unreadToken;</span>
    }

    /**
     * Returns the next token on the stream, or null if there are no more JSON
     * tokens on the stream.
     * @return The next token, or null.
     * @throws IOException If unable to read from stream.
     */
    @Nullable
    public Token next() throws IOException {
<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (unreadToken != null) {</span>
<span class="fc" id="L265">            Token tmp = unreadToken;</span>
<span class="fc" id="L266">            unreadToken = null;</span>
<span class="fc" id="L267">            return tmp;</span>
        }

<span class="fc bfc" id="L270" title="All 2 branches covered.">        while (lastChar &gt;= 0) {</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (lastChar == 0) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                if (!readNextChar()) {</span>
<span class="fc" id="L273">                    break;</span>
                }
            }
<span class="pc bpc" id="L276" title="1 of 8 branches missed.">            if (lastChar == Token.kNewLine ||</span>
                lastChar == Token.kCarriageReturn ||
                lastChar == Token.kSpace ||
                lastChar == Token.kTab) {
<span class="fc" id="L280">                lastChar = 0;</span>
<span class="fc" id="L281">                continue;</span>
            }

<span class="fc bfc" id="L284" title="All 2 branches covered.">            if (lastChar == Token.kShellComment) {</span>
<span class="fc" id="L285">                getRestOfLine();</span>
<span class="fc" id="L286">                continue;</span>
            }

<span class="pc bpc" id="L289" title="1 of 4 branches missed.">            if (lastChar == Token.kLiteralDoubleQuote || lastChar == Token.kLiteralQuote) {</span>
<span class="fc" id="L290">                return nextStringLiteral((char) lastChar);</span>
<span class="fc bfc" id="L291" title="All 8 branches covered.">            } else if (lastChar == '.' || lastChar == '-' || (lastChar &gt;= '0' &amp;&amp; lastChar &lt;= '9')) {</span>
<span class="fc" id="L292">                return nextNumber();</span>
<span class="pc bpc" id="L293" title="1 of 10 branches missed.">            } else if ('_' == lastChar ||</span>
                       ('a' &lt;= lastChar &amp;&amp; lastChar &lt;= 'z') ||
                       ('A' &lt;= lastChar &amp;&amp; lastChar &lt;= 'Z')) {
<span class="fc" id="L296">                return nextToken();</span>
<span class="pc bpc" id="L297" title="2 of 4 branches missed.">            } else if (lastChar &lt; 0x20 || lastChar &gt;= 0x7F) {</span>
                // non-ASCII UTF-8 characters are only allowed inside JSON string literals.
<span class="nc" id="L299">                throw failure(lineNo, linePos, 1, &quot;Unknown token initiator '%s'&quot;, Strings.escape((char) lastChar));</span>
            } else {
<span class="fc" id="L301">                return nextSymbol();</span>
            }
        }

<span class="fc" id="L305">        return null;</span>
    }

    // --- INTERNAL ---

    @Nonnull
    protected Token nextSymbol() throws IOException {
<span class="fc" id="L312">        lastChar = 0;</span>
<span class="fc" id="L313">        return new Token(buffer, bufferOffset, 1, lineNo, linePos);</span>
    }

    @Nonnull
    private Token nextToken() throws IOException {
<span class="fc" id="L318">        maybeConsolidateBuffer();</span>

<span class="fc" id="L320">        int startPos = linePos;</span>
<span class="fc" id="L321">        int startOffset = bufferOffset;</span>
<span class="fc" id="L322">        int startLine = lineNo;</span>
<span class="fc" id="L323">        int len = 0;</span>

<span class="fc" id="L325">        int lastLast = 0;</span>
<span class="fc bfc" id="L326" title="All 16 branches covered.">        while (lastChar == '_' || lastChar == '.' ||</span>
               (lastChar &gt;= '0' &amp;&amp; lastChar &lt;= '9') ||
               (lastChar &gt;= 'a' &amp;&amp; lastChar &lt;= 'z') ||
               (lastChar &gt;= 'A' &amp;&amp; lastChar &lt;= 'Z')) {
<span class="fc bfc" id="L330" title="All 4 branches covered.">            if (lastChar == '.' &amp;&amp; lastLast == '.') {</span>
<span class="fc" id="L331">                throw failure(lineNo, startPos, bufferOffset - startOffset + 1,</span>
                              &quot;Identifier with double '.'&quot;);
<span class="pc bpc" id="L333" title="1 of 6 branches missed.">            } else if (lastLast == '.' &amp;&amp;</span>
                       ('0' &lt;= lastChar &amp;&amp; lastChar &lt;= '9')) {
<span class="fc" id="L335">                throw failure(lineNo, startPos, bufferOffset - startOffset + 1,</span>
<span class="fc" id="L336">                              &quot;Identifier part starting with digit '%c'&quot;, lastChar);</span>
            }
<span class="fc" id="L338">            lastLast = lastChar;</span>
<span class="fc" id="L339">            ++len;</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">            if (!readNextChar()) {</span>
<span class="fc" id="L341">                break;</span>
            }
        }

<span class="fc bfc" id="L345" title="All 2 branches covered.">        if (lastLast == '.') {</span>
<span class="fc" id="L346">            throw failure(lineNo, startPos, bufferOffset - startOffset,</span>
                          &quot;Identifier with trailing '.'&quot;);
        }

<span class="fc" id="L350">        return new Token(buffer, startOffset, len, startLine, startPos);</span>
    }

    @Nonnull
    private Token nextNumber() throws IOException {
<span class="fc" id="L355">        maybeConsolidateBuffer();</span>
        // NOTE: This code is pretty messy because it is a full state-engine
        // to ensure that the parsed number follows the JSON number syntax.
        // Alternatives are:
        //
        // dec = -?0
        // dec = -?.0
        // dec = -?0.0
        // sci = (dec)[eE][+-]?[0-9]+
        // hex = 0x[0-9a-fA-F]+
        // oct = 0[0-7]+
        //
        // It is programmed as a state-engine to be very efficient, but
        // correctly detect valid JSON (and what is invalid if not).

<span class="fc" id="L370">        int startPos = linePos;</span>
<span class="fc" id="L371">        int startOffset = bufferOffset;</span>
        // number (any type).
<span class="fc" id="L373">        int len = 0;</span>

<span class="fc bfc" id="L375" title="All 2 branches covered.">        if (lastChar == '-') {</span>
            // only base 10 decimals can be negative.
<span class="fc" id="L377">            ++len;</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">            if (!readNextChar()) {</span>
<span class="fc" id="L379">                throw failure(lineNo, startPos, bufferOffset - startOffset,</span>
                              &quot;Negative indicator without number&quot;);
            }

<span class="pc bpc" id="L383" title="2 of 6 branches missed.">            if (!(lastChar == '.' || (lastChar &gt;= '0' &amp;&amp; lastChar &lt;= '9'))) {</span>
<span class="fc" id="L384">                throw failure(lineNo, startPos, bufferOffset - startOffset,</span>
                              &quot;No decimal after negative indicator&quot;);
            }
<span class="fc bfc" id="L387" title="All 2 branches covered.">        } else if (lastChar == '0') {</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">            if (readNextChar()) {</span>
<span class="fc" id="L389">                ++len;</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">                if (lastChar == 'x') {</span>
<span class="fc" id="L391">                    ++len;</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">                    if (!readNextChar()) {</span>
<span class="nc" id="L393">                        throw failure(lineNo, startPos, bufferOffset - startOffset + 1,</span>
                                      &quot;No decimal after hex indicator&quot;);
                    }
                    // hexadecimal.
                    do {
<span class="pc bpc" id="L398" title="7 of 12 branches missed.">                        if (!((lastChar &gt;= '0' &amp;&amp; lastChar &lt;= '9') || (lastChar &gt;= 'a' &amp;&amp; lastChar &lt;= 'f') ||</span>
                              (lastChar &gt;= 'A' &amp;&amp; lastChar &lt;= 'F'))) {
                            // we read a char that's *not* part of the hex number.
<span class="nc" id="L401">                            break;</span>
                        }
<span class="fc" id="L403">                        ++len;</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">                    } while (readNextChar());</span>

<span class="fc" id="L406">                    return validateAfterNumber(startOffset, startPos, len);</span>
<span class="pc bpc" id="L407" title="1 of 4 branches missed.">                } else if ('0' &lt;= lastChar &amp;&amp; lastChar &lt;= '7') {</span>
<span class="fc" id="L408">                    ++len;</span>
                    // Octals have 0 in front, and then more digits.
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">                    while (readNextChar()) {</span>
<span class="pc bpc" id="L411" title="1 of 4 branches missed.">                        if (lastChar &lt; '0' || lastChar &gt; '7') {</span>
<span class="fc" id="L412">                            break;</span>
                        }
<span class="fc" id="L414">                        ++len;</span>
                    }
<span class="fc" id="L416">                    return validateAfterNumber(startOffset, startPos, len);</span>
                }
            } else {
                // just '0'
<span class="nc" id="L420">                return validateAfterNumber(startOffset, startPos, 1);</span>
            }
        }

        // decimal part.
<span class="fc bfc" id="L425" title="All 4 branches covered.">        while (lastChar &gt;= '0' &amp;&amp; lastChar &lt;= '9') {</span>
<span class="fc" id="L426">            ++len;</span>
            // numbers are terminated by first non-numeric character.
<span class="fc bfc" id="L428" title="All 2 branches covered.">            if (!readNextChar()) {</span>
<span class="fc" id="L429">                break;</span>
            }
        }
        // fraction part.
<span class="fc bfc" id="L433" title="All 2 branches covered.">        if (lastChar == '.') {</span>
<span class="fc" id="L434">            ++len;</span>
            // numbers are terminated by first non-numeric character.
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">            if (readNextChar()) {</span>
<span class="fc bfc" id="L437" title="All 4 branches covered.">                while (lastChar &gt;= '0' &amp;&amp; lastChar &lt;= '9') {</span>
<span class="fc" id="L438">                    ++len;</span>
                    // numbers are terminated by first non-numeric character.
<span class="fc bfc" id="L440" title="All 2 branches covered.">                    if (!readNextChar()) {</span>
<span class="fc" id="L441">                        break;</span>
                    }
                }
            }
        }
        // exponent part.
<span class="fc bfc" id="L447" title="All 4 branches covered.">        if (lastChar == 'e' || lastChar == 'E') {</span>
<span class="fc" id="L448">            ++len;</span>
            // numbers are terminated by first non-numeric character.
<span class="fc bfc" id="L450" title="All 2 branches covered.">            if (!readNextChar()) {</span>
<span class="fc" id="L451">                String tmp = new String(buffer, startOffset, len);</span>
<span class="fc" id="L452">                throw failure(lineNo, startPos, bufferOffset - startOffset + 1,</span>
                              &quot;Badly terminated number exponent: '%s'&quot;, tmp);
            }

            // The exponent can be explicitly prefixed with both '+'
            // and '-'.
<span class="fc bfc" id="L458" title="All 4 branches covered.">            if (lastChar == '-' || lastChar == '+') {</span>
<span class="fc" id="L459">                ++len;</span>
                // numbers are terminated by first non-numeric character.
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">                if (!readNextChar()) {</span>
<span class="nc" id="L462">                    String tmp = new String(buffer, startOffset, len);</span>
<span class="nc" id="L463">                    throw failure(lineNo, startPos, bufferOffset - startOffset + 1,</span>
                                  &quot;Badly terminated number exponent: '%s'&quot;, tmp);
                }
            }

<span class="pc bpc" id="L468" title="1 of 4 branches missed.">            if (lastChar &gt;= '0' &amp;&amp; lastChar &lt;= '9') {</span>
<span class="fc bfc" id="L469" title="All 4 branches covered.">                while (lastChar &gt;= '0' &amp;&amp; lastChar &lt;= '9') {</span>
<span class="fc" id="L470">                    ++len;</span>
                    // numbers are terminated by first non-numeric character.
<span class="fc bfc" id="L472" title="All 2 branches covered.">                    if (!readNextChar()) {</span>
<span class="fc" id="L473">                        break;</span>
                    }
                }
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">            } else if (lastChar &gt; 0) {</span>
<span class="fc" id="L477">                String tmp = new String(buffer, startOffset, len + 1);</span>
<span class="fc" id="L478">                throw failure(lineNo, startPos, bufferOffset - startOffset + 1,</span>
                              &quot;Badly terminated number exponent: '%s'&quot;, tmp);
            } else {
<span class="nc" id="L481">                String tmp = new String(buffer, startOffset, len + 1);</span>
<span class="nc" id="L482">                throw failure(lineNo, startPos, bufferOffset - startOffset,</span>
                              &quot;Badly terminated number exponent: '%s'&quot;, tmp);
            }
        }

<span class="fc" id="L487">        return validateAfterNumber(startOffset, startPos, len);</span>
    }

    private Token validateAfterNumber(int startOffset, int startLinePos, int len)
            throws TokenizerException {
        // A number must be terminated correctly: End of stream, space or a
        // symbol that may be after a value: ',' '}' ']'.
<span class="pc bpc" id="L494" title="2 of 10 branches missed.">        if (lastChar == '_' ||</span>
            (lastChar &gt;= 'a' &amp;&amp; lastChar &lt;= 'z') ||
            (lastChar &gt;= 'A' &amp;&amp; lastChar &lt;= 'Z')) {
<span class="fc" id="L497">            String tmp = new String(buffer, startOffset, len + 1);</span>
<span class="fc" id="L498">            throw failure(lineNo, startLinePos, bufferOffset - startOffset + 1,</span>
                          &quot;Invalid termination of number: '%s'&quot;, tmp);
        } else {
<span class="fc" id="L501">            return new Token(buffer, startOffset, len, lineNo, startLinePos);</span>
        }
    }

    @Nonnull
    private Token nextStringLiteral(char quote) throws IOException {
<span class="fc" id="L507">        maybeConsolidateBuffer();</span>

        // string literals may be longer than 128 bytes. We may need to build it.
<span class="fc" id="L510">        StringBuilder consolidatedString = null;</span>

<span class="fc" id="L512">        int startPos = linePos;</span>
<span class="fc" id="L513">        int startOffset = bufferOffset;</span>

<span class="fc" id="L515">        boolean esc = false;</span>
        for (; ; ) {
<span class="pc bpc" id="L517" title="1 of 4 branches missed.">            if (!preLoaded &amp;&amp; bufferOffset &gt;= (bufferLimit - 1)) {</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">                if (consolidatedString == null) {</span>
<span class="fc" id="L519">                    consolidatedString = new StringBuilder();</span>
                }
<span class="fc" id="L521">                consolidatedString.append(buffer, startOffset, bufferOffset - startOffset + 1);</span>
<span class="fc" id="L522">                startOffset = 0;</span>
            }

<span class="fc bfc" id="L525" title="All 2 branches covered.">            if (!readNextChar()) {</span>
<span class="fc" id="L526">                throw failure(lineNo, startPos, bufferOffset - startOffset + 1,</span>
                              &quot;Unexpected end of stream in string literal&quot;);
            }

<span class="fc bfc" id="L530" title="All 2 branches covered.">            if (esc) {</span>
<span class="fc" id="L531">                esc = false;</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">            } else if (lastChar == Token.kLiteralEscape) {</span>
<span class="fc" id="L533">                esc = true;</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">            } else if (lastChar == quote) {</span>
<span class="fc" id="L535">                break;</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">            } else if (lastChar == Token.kNewLine) {</span>
<span class="fc" id="L537">                throw failure(lineNo, startPos, bufferOffset - startOffset,</span>
                              &quot;Unexpected newline in string literal&quot;);
<span class="pc bpc" id="L539" title="1 of 6 branches missed.">            } else if (lastChar &lt; 0x20 || lastChar == 0x7f ||</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">                       (lastChar &gt; 0x7f &amp;&amp; !Strings.isConsolePrintable(lastChar))) {</span>
<span class="fc" id="L541">                throw failure(lineNo, startPos, bufferOffset - startOffset + 1,</span>
<span class="fc" id="L542">                              &quot;Unescaped non-printable char in literal: '%s'&quot;, Strings.escape((char) lastChar));</span>
            }
        }

<span class="fc" id="L546">        lastChar = 0;</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        if (consolidatedString != null) {</span>
<span class="nc" id="L548">            consolidatedString.append(buffer, 0, bufferOffset + 1);</span>
<span class="nc" id="L549">            String result = consolidatedString.toString();</span>
<span class="nc" id="L550">            return new Token(result.toCharArray(), 0, result.length(), lineNo, startPos);</span>
        } else {
<span class="fc" id="L552">            return new Token(buffer, startOffset, bufferOffset - startOffset + 1, lineNo, startPos);</span>
        }
    }

    @Nonnull
    public TokenizerException failure(Token token, String message, Object... params) {
<span class="fc" id="L558">        return failure(token.getLineNo(),</span>
<span class="fc" id="L559">                       token.getLinePos(),</span>
<span class="fc" id="L560">                       token.length(),</span>
                       message, params);
    }

    @Nonnull
    protected final TokenizerException failure(int startLineNo,
                                         int startLinePos,
                                         int length,
                                         String format,
                                         Object... params) {
<span class="fc" id="L570">        return failure(format, params).setLineNo(startLineNo)</span>
<span class="fc" id="L571">                                      .setLinePos(startLinePos)</span>
<span class="fc" id="L572">                                      .setLine(getLine())</span>
<span class="fc" id="L573">                                      .setLength(length);</span>
    }

    @Nonnull
    protected final TokenizerException eof(String format, Object ... params) {
<span class="fc" id="L578">        return failure(format, params)</span>
<span class="fc" id="L579">                .setLinePos(getLinePos() + 1)</span>
<span class="fc" id="L580">                .setLength(1)</span>
<span class="fc" id="L581">                .setLineNo(getLineNo())</span>
<span class="fc" id="L582">                .setLine(getLine());</span>
    }

    @Nonnull
    protected TokenizerException failure(String format, Object ... params) {
<span class="fc" id="L587">        return new TokenizerException(format, params);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>