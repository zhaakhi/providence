<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EqualToMessage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Utils : Testing</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.testing</a> &gt; <span class="el_source">EqualToMessage.java</span></div><h1>EqualToMessage.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016 Providence Authors
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package net.morimekta.providence.testing;

import net.morimekta.providence.PEnumValue;
import net.morimekta.providence.PMessage;
import net.morimekta.providence.PMessageVariant;
import net.morimekta.providence.PUnion;
import net.morimekta.providence.descriptor.PField;
import net.morimekta.util.Binary;
import net.morimekta.util.Strings;

import junit.framework.AssertionFailedError;
import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * @author Stein Eldar Johnsen
 * @since 21.01.16.
 */
public class EqualToMessage&lt;Message extends PMessage&lt;Message, Field&gt;, Field extends PField&gt;
        extends BaseMatcher&lt;Message&gt; {
    private final Message expected;

<span class="fc" id="L52">    public EqualToMessage(Message expected) {</span>
<span class="fc" id="L53">        this.expected = expected;</span>
<span class="fc" id="L54">    }</span>

    @Override
    public boolean matches(Object actual) {
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">        if (expected == null) {</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">            return actual == null;</span>
        }
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">        if (!(actual instanceof PMessage)) {</span>
<span class="nc" id="L62">            throw new AssertionFailedError(&quot;Item &quot; + actual.getClass().toString() + &quot; not a providence message.&quot;);</span>
        }
<span class="fc" id="L64">        return expected.equals(actual);</span>
    }

    @Override
    public void describeTo(Description description) {
<span class="fc" id="L69">        description.appendText(&quot;equals(&quot;)</span>
<span class="fc" id="L70">                   .appendText(limitToString(expected))</span>
<span class="fc" id="L71">                   .appendText(&quot;)&quot;);</span>
<span class="fc" id="L72">    }</span>

    @Override
    public void describeMismatch(Object actual, Description mismatchDescription) {
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        if (expected == null) {</span>
<span class="nc" id="L77">            mismatchDescription.appendText(&quot;got &quot; + toString(actual));</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        } else if (actual == null) {</span>
<span class="nc" id="L79">            mismatchDescription.appendText(&quot;got null&quot;);</span>
        } else {
<span class="fc" id="L81">            ArrayList&lt;String&gt; mismatches = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L82">            collectMismatches(&quot;&quot;, (PMessage) expected, (PMessage) actual, mismatches);</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">            if (mismatches.size() == 1) {</span>
<span class="fc" id="L84">                mismatchDescription.appendText(mismatches.get(0));</span>
            } else {
<span class="nc" id="L86">                boolean first = true;</span>
<span class="nc" id="L87">                mismatchDescription.appendText(&quot;[&quot;);</span>
<span class="nc" id="L88">                int i = 0;</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">                for (String mismatch : mismatches) {</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">                    if (first) {</span>
<span class="nc" id="L91">                        first = false;</span>
                    } else {
<span class="nc" id="L93">                        mismatchDescription.appendText(&quot;,&quot;);</span>
                    }
<span class="nc" id="L95">                    mismatchDescription.appendText(&quot;\n        &quot;);</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">                    if (i &gt;= 20) {</span>
<span class="nc" id="L97">                        int remaining = mismatches.size() - i;</span>
<span class="nc" id="L98">                        mismatchDescription.appendText(&quot;... and &quot; + remaining + &quot;more&quot;);</span>
<span class="nc" id="L99">                        break;</span>
                    }
<span class="nc" id="L101">                    mismatchDescription.appendText(mismatch);</span>
<span class="nc" id="L102">                    ++i;</span>
<span class="nc" id="L103">                }</span>
<span class="nc" id="L104">                mismatchDescription.appendText(&quot;\n     ]&quot;);</span>
            }
        }
<span class="fc" id="L107">    }</span>

    private static &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt;
    void collectMismatches(String xPath, T expected, T actual, ArrayList&lt;String&gt; mismatches) {
        // This is pretty heavy calculation, but since it's only done on
        // mismatch / test failure, it should be fine.
<span class="fc" id="L113">        if (expected.descriptor()</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">                    .getVariant() == PMessageVariant.UNION) {</span>
<span class="fc" id="L115">            PUnion&lt;?,?&gt; eu = (PUnion) expected;</span>
<span class="fc" id="L116">            PUnion&lt;?,?&gt; ac = (PUnion) actual;</span>

<span class="fc" id="L118">            if (!eu.unionField()</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">                   .equals(ac.unionField())) {</span>
<span class="nc" id="L120">                mismatches.add(String.format(&quot;%s to have %s, but had %s&quot;,</span>
                                             xPath,
<span class="nc" id="L122">                                             eu.unionField()</span>
<span class="nc" id="L123">                                               .getName(),</span>
<span class="nc" id="L124">                                             ac.unionField()</span>
<span class="nc" id="L125">                                               .getName()));</span>
            }
        }

<span class="fc bfc" id="L129" title="All 2 branches covered.">        for (PField field : expected.descriptor()</span>
<span class="fc" id="L130">                                       .getFields()) {</span>
<span class="fc" id="L131">            int key = field.getId();</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">            String fieldXPath = xPath.isEmpty() ? field.getName() : xPath + &quot;.&quot; + field.getName();</span>

<span class="pc bpc" id="L134" title="1 of 2 branches missed.">            if (expected.has(key) != actual.has(key)) {</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">                if (!expected.has(key)) {</span>
<span class="nc" id="L136">                    mismatches.add(String.format(&quot;%s to be missing, but was %s&quot;,</span>
                                                 fieldXPath,
<span class="nc" id="L138">                                                 toString(actual.get(field.getId()))));</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">                } else if (!actual.has(key)) {</span>
<span class="nc" id="L140">                    mismatches.add(String.format(&quot;%s to be %s, but was missing&quot;,</span>
                                                 fieldXPath,
<span class="nc" id="L142">                                                 toString(expected.get(field.getId()))));</span>
                }
<span class="fc bfc" id="L144" title="All 2 branches covered.">            } else if (!Objects.equals(expected.get(key), actual.get(key))) {</span>
<span class="pc bpc" id="L145" title="2 of 5 branches missed.">                switch (field.getType()) {</span>
                    case MESSAGE: {
<span class="fc" id="L147">                        collectMismatches(fieldXPath,</span>
<span class="fc" id="L148">                                          (PMessage) expected.get(key),</span>
<span class="fc" id="L149">                                          (PMessage) actual.get(key),</span>
                                          mismatches);
<span class="fc" id="L151">                        break;</span>
                    }
                    case LIST: {
<span class="fc" id="L154">                        collectListMismatches(fieldXPath, (List) expected.get(key), (List) actual.get(key), mismatches);</span>
<span class="fc" id="L155">                        break;</span>
                    }
                    case SET: {
<span class="nc" id="L158">                        collectSetMismatches(fieldXPath, (Set) expected.get(key), (Set) actual.get(key), mismatches);</span>
<span class="nc" id="L159">                        break;</span>
                    }
                    case MAP: {
<span class="nc" id="L162">                        collectMapMismatches(fieldXPath, (Map) expected.get(key), (Map) actual.get(key), mismatches);</span>
<span class="nc" id="L163">                        break;</span>
                    }
                    default: {
<span class="fc" id="L166">                        mismatches.add(String.format(&quot;%s was %s, expected %s&quot;,</span>
                                                     fieldXPath,
<span class="fc" id="L168">                                                     toString(actual.get(field.getId())),</span>
<span class="fc" id="L169">                                                     toString(expected.get(field.getId()))));</span>
                        break;
                    }
                }
            }
        }
<span class="fc" id="L175">    }</span>

    private static &lt;K, V&gt; void collectMapMismatches(String xPath,
                                                    Map&lt;K, V&gt; expected,
                                                    Map&lt;K, V&gt; actual,
                                                    ArrayList&lt;String&gt; mismatches) {
<span class="nc" id="L181">        mismatches.addAll(actual.keySet()</span>
<span class="nc" id="L182">                                .stream()</span>
<span class="nc" id="L183">                                .filter(key -&gt; !expected.keySet()</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">                                                        .contains(key))</span>
<span class="nc" id="L185">                                .map(key -&gt; String.format(&quot;found unexpected entry (%s, %s) in %s&quot;,</span>
<span class="nc" id="L186">                                                          toString(key),</span>
<span class="nc" id="L187">                                                          toString(actual.get(key)),</span>
                                                          xPath))
<span class="nc" id="L189">                                .collect(Collectors.toList()));</span>

<span class="nc bnc" id="L191" title="All 2 branches missed.">        for (Map.Entry&lt;K,V&gt; entry : expected.entrySet()) {</span>
<span class="nc" id="L192">            if (!actual.keySet()</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">                       .contains(entry.getKey())) {</span>
<span class="nc" id="L194">                mismatches.add(String.format(&quot;did not find entry (%s, %s) in in %s&quot;,</span>
<span class="nc" id="L195">                                             toString(entry.getKey()),</span>
<span class="nc" id="L196">                                             toString(expected.get(entry.getKey())),</span>
                                             xPath));
            } else {
<span class="nc" id="L199">                V exp = entry.getValue();</span>
<span class="nc" id="L200">                V act = actual.get(entry.getKey());</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">                if (!Objects.equals(exp, act)) {</span>
                    // value differs.
<span class="nc" id="L203">                    String keyedXPath = String.format(&quot;%s[%s]&quot;, xPath, toString(entry));</span>
<span class="nc bnc" id="L204" title="All 4 branches missed.">                    if (exp == null || act == null) {</span>
<span class="nc" id="L205">                        mismatches.add(String.format(&quot;%s was %s, should be %s&quot;,</span>
                                                     keyedXPath,
<span class="nc" id="L207">                                                     toString(exp),</span>
<span class="nc" id="L208">                                                     toString(act)));</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                    } else if (act instanceof PMessage) {</span>
<span class="nc" id="L210">                        collectMismatches(keyedXPath, (PMessage) exp, (PMessage) act, mismatches);</span>
                    } else {
<span class="nc" id="L212">                        mismatches.add(String.format(&quot;%s was %s, should be %s&quot;,</span>
                                                     keyedXPath,
<span class="nc" id="L214">                                                     toString(act),</span>
<span class="nc" id="L215">                                                     toString(exp)));</span>
                    }
                }
            }
<span class="nc" id="L219">        }</span>
<span class="nc" id="L220">    }</span>

    private static &lt;T&gt; void collectSetMismatches(String xPath,
                                                 Set&lt;T&gt; expected,
                                                 Set&lt;T&gt; actual,
                                                 ArrayList&lt;String&gt; mismatches) {
        // order does NOT matter regardless of type. The only
        // errors are missing and unexpected values. Partial
        // matches are not checked.
<span class="nc" id="L229">        mismatches.addAll(actual.stream()</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">                                .filter(item -&gt; !expected.contains(item))</span>
<span class="nc" id="L231">                                .map(item -&gt; String.format(&quot;found unexpected set value %s in %s&quot;,</span>
<span class="nc" id="L232">                                                           toString(item),</span>
                                                           xPath))
<span class="nc" id="L234">                                .collect(Collectors.toList()));</span>

<span class="nc" id="L236">        mismatches.addAll(expected.stream()</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                                  .filter(item -&gt; !actual.contains(item))</span>
<span class="nc" id="L238">                                  .map(item -&gt; String.format(&quot;did not find value %s in %s&quot;, toString(item), xPath))</span>
<span class="nc" id="L239">                                  .collect(Collectors.toList()));</span>

<span class="nc" id="L241">    }</span>

    private static &lt;T&gt; void collectListMismatches(String xPath,
                                                  List&lt;T&gt; expected,
                                                  List&lt;T&gt; actual,
                                                  ArrayList&lt;String&gt; mismatches) {
<span class="fc" id="L247">        Set&lt;T&gt; handledItems = new HashSet&lt;&gt;();</span>

<span class="fc" id="L249">        boolean hasReorder = false;</span>
<span class="fc" id="L250">        ArrayList&lt;String&gt; reordering = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">        for (int expectedIndex = 0; expectedIndex &lt; expected.size(); ++expectedIndex) {</span>
<span class="fc" id="L252">            String indexedXPath = String.format(&quot;%s[%d]&quot;, xPath, expectedIndex);</span>
<span class="fc" id="L253">            T expectedItem = expected.get(expectedIndex);</span>
<span class="fc" id="L254">            handledItems.add(expectedItem);</span>

<span class="pc bpc" id="L256" title="1 of 2 branches missed.">            T actualItem = actual.size() &gt; expectedIndex ? actual.get(expectedIndex) : null;</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">            if (Objects.equals(expectedItem, actualItem)) {</span>
<span class="fc" id="L258">                continue;</span>
            }
<span class="fc" id="L260">            int actualIndex = actual.indexOf(expectedItem);</span>

<span class="fc" id="L262">            int actualItemExpectedIndex = -1;</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">            if (actualItem != null) {</span>
<span class="fc" id="L264">                actualItemExpectedIndex = expected.indexOf(actualItem);</span>
            }

<span class="pc bpc" id="L267" title="1 of 2 branches missed.">            if (actualIndex &lt; 0) {</span>
<span class="fc" id="L268">                reordering.add(&quot;NaN&quot;);</span>
                // this item is missing.
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">                if (actualItemExpectedIndex &lt; 0) {</span>
<span class="fc" id="L271">                    handledItems.add(actualItem);</span>
                    // replaced with new item, diff them normally.
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">                    if (actualItem instanceof PMessage) {</span>
<span class="fc" id="L274">                        collectMismatches(indexedXPath, (PMessage) expectedItem, (PMessage) actualItem, mismatches);</span>
                    } else {
<span class="nc" id="L276">                        mismatches.add(String.format(&quot;expected %s to be %s, but was %s&quot;,</span>
                                                     indexedXPath,
<span class="nc" id="L278">                                                     toString(expectedItem),</span>
<span class="nc" id="L279">                                                     toString(actualItem)));</span>
                    }
                } else {
                    // the other item is reordered, so this is blindly inserted.
<span class="nc" id="L283">                    mismatches.add(String.format(&quot;missing item %s in %s&quot;, toString(expectedItem), indexedXPath));</span>
                }
<span class="nc bnc" id="L285" title="All 2 branches missed.">            } else if (actualIndex != expectedIndex) {</span>
<span class="nc" id="L286">                reordering.add(String.format(&quot;%+d&quot;, actualIndex - expectedIndex));</span>
<span class="nc" id="L287">                hasReorder = true;</span>
            } else {
<span class="nc" id="L289">                reordering.add(&quot;±0&quot;);</span>
            }
        }
<span class="fc bfc" id="L292" title="All 2 branches covered.">        for (int actualIndex = 0; actualIndex &lt; actual.size(); ++actualIndex) {</span>
<span class="fc" id="L293">            T actualItem = actual.get(actualIndex);</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">            if (handledItems.contains(actualItem)) {</span>
<span class="fc" id="L295">                continue;</span>
            }
<span class="nc bnc" id="L297" title="All 2 branches missed.">            if (expected.contains(actualItem)) {</span>
<span class="nc" id="L298">                continue;</span>
            }
<span class="nc" id="L300">            String indexedXPath = String.format(&quot;%s[%d]&quot;, xPath, actualIndex);</span>
<span class="nc" id="L301">            mismatches.add(String.format(&quot;unexpected item %s in %s&quot;, toString(actualItem), indexedXPath));</span>
        }
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (hasReorder) {</span>
<span class="nc" id="L304">            mismatches.add(String.format(&quot;unexpected item ordering in %s: [%s]&quot;, xPath, Strings.join(&quot;,&quot;, reordering)));</span>
        }

<span class="fc" id="L307">    }</span>

    protected static String toString(Object o) {
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (o == null) {</span>
<span class="nc" id="L311">            return &quot;null&quot;;</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        } else if (o instanceof PMessage) {</span>
<span class="nc" id="L313">            return limitToString((PMessage) o);</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        } else if (o instanceof PEnumValue) {</span>
<span class="nc" id="L315">            return ((PEnumValue) o).descriptor()</span>
<span class="nc" id="L316">                                   .getName() + &quot;.&quot; + ((PEnumValue) o).asString();</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        } else if (o instanceof Map) {</span>
<span class="nc" id="L318">            return &quot;{&quot; + Strings.join(&quot;,&quot;,</span>
<span class="nc" id="L319">                                      ((Map&lt;?, ?&gt;) o).entrySet()</span>
<span class="nc" id="L320">                                                     .stream()</span>
<span class="nc" id="L321">                                                     .map(e -&gt; toString(e.getKey()) + &quot;:&quot; + toString(e.getValue()))</span>
<span class="nc" id="L322">                                                     .collect(Collectors.toList())) + &quot;}&quot;;</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">        } else if (o instanceof Collection) {</span>
<span class="nc" id="L324">            return &quot;[&quot; + Strings.join(&quot;,&quot;,</span>
<span class="nc" id="L325">                                      ((Collection&lt;?&gt;) o).stream()</span>
<span class="nc" id="L326">                                                         .map(EqualToMessage::toString)</span>
<span class="nc" id="L327">                                                         .collect(Collectors.toList())) + &quot;]&quot;;</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        } else if (o instanceof CharSequence) {</span>
<span class="nc" id="L329">            return &quot;\&quot;&quot; + Strings.escape(o.toString()) + &quot;\&quot;&quot;;</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        } else if (o instanceof Binary) {</span>
<span class="nc" id="L331">            int len = ((Binary) o).length();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (len &gt; 110) {</span>
<span class="nc" id="L333">                return String.format(&quot;binary[%s...+%d]&quot;,</span>
<span class="nc" id="L334">                                     ((Binary) o).toHexString()</span>
<span class="nc" id="L335">                                                 .substring(0, 100),</span>
<span class="nc" id="L336">                                     len - 50);</span>
            } else {
<span class="nc" id="L338">                return &quot;binary[&quot; + ((Binary) o).toHexString() + &quot;]&quot;;</span>
            }
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">        } else if (o instanceof Double) {</span>
<span class="fc" id="L341">            long l = ((Double) o).longValue();</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">            if (o.equals((double) l)) {</span>
<span class="nc" id="L343">                return Long.toString(l);</span>
            } else {
<span class="fc" id="L345">                return o.toString();</span>
            }
        } else {
<span class="nc" id="L348">            return o.toString();</span>
        }
    }

    private static String limitToString(PMessage&lt;?, ?&gt; message) {
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">        String tos = message == null ? &quot;null&quot; : message.asString();</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (tos.length() &gt; 120) {</span>
<span class="fc" id="L355">            tos = tos.substring(0, 110) + &quot;...}&quot;;</span>
        }

<span class="fc" id="L358">        return tos;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>