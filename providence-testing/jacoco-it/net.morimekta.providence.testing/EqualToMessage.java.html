<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EqualToMessage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Utils : Testing</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.testing</a> &gt; <span class="el_source">EqualToMessage.java</span></div><h1>EqualToMessage.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016 Providence Authors
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package net.morimekta.providence.testing;

import net.morimekta.providence.PEnumValue;
import net.morimekta.providence.PMessage;
import net.morimekta.providence.PMessageVariant;
import net.morimekta.providence.PUnion;
import net.morimekta.providence.descriptor.PField;
import net.morimekta.util.Binary;
import net.morimekta.util.Strings;
import net.morimekta.util.json.JsonException;
import net.morimekta.util.json.JsonWriter;

import junit.framework.AssertionFailedError;
import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;

import java.io.ByteArrayOutputStream;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * @author Stein Eldar Johnsen
 * @since 21.01.16.
 */
public class EqualToMessage&lt;Message extends PMessage&lt;Message, Field&gt;, Field extends PField&gt;
        extends BaseMatcher&lt;Message&gt; {
    private final Message expected;

<span class="nc" id="L57">    public EqualToMessage(Message expected) {</span>
<span class="nc" id="L58">        this.expected = expected;</span>
<span class="nc" id="L59">    }</span>

    @Override
    public boolean matches(Object actual) {
<span class="nc bnc" id="L63" title="All 2 branches missed.">        if (expected == null) {</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">            return actual == null;</span>
        }
<span class="nc bnc" id="L66" title="All 2 branches missed.">        if (!(actual instanceof PMessage)) {</span>
<span class="nc" id="L67">            throw new AssertionFailedError(&quot;Item &quot; + actual.getClass().toString() + &quot; not a providence message.&quot;);</span>
        }
<span class="nc" id="L69">        return expected.equals(actual);</span>
    }

    @Override
    public void describeTo(Description description) {
<span class="nc" id="L74">        description.appendText(&quot;equals(&quot;)</span>
<span class="nc" id="L75">                   .appendText(limitToString(expected))</span>
<span class="nc" id="L76">                   .appendText(&quot;)&quot;);</span>
<span class="nc" id="L77">    }</span>

    @Override
    public void describeMismatch(Object actual, Description mismatchDescription) {
<span class="nc bnc" id="L81" title="All 2 branches missed.">        if (expected == null) {</span>
<span class="nc" id="L82">            mismatchDescription.appendText(&quot;got &quot; + toString(actual));</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        } else if (actual == null) {</span>
<span class="nc" id="L84">            mismatchDescription.appendText(&quot;got null&quot;);</span>
        } else {
<span class="nc" id="L86">            LinkedList&lt;String&gt; mismatches = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L87">            collectMismatches(&quot;&quot;, (PMessage) expected, (PMessage) actual, mismatches);</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">            if (mismatches.size() == 1) {</span>
<span class="nc" id="L89">                mismatchDescription.appendText(mismatches.getFirst());</span>
            } else {
<span class="nc" id="L91">                boolean first = true;</span>
<span class="nc" id="L92">                mismatchDescription.appendText(&quot;[&quot;);</span>
<span class="nc" id="L93">                int i = 0;</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">                for (String mismatch : mismatches) {</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">                    if (first) {</span>
<span class="nc" id="L96">                        first = false;</span>
                    } else {
<span class="nc" id="L98">                        mismatchDescription.appendText(&quot;,&quot;);</span>
                    }
<span class="nc" id="L100">                    mismatchDescription.appendText(&quot;\n        &quot;);</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">                    if (i &gt;= 20) {</span>
<span class="nc" id="L102">                        int remaining = mismatches.size() - i;</span>
<span class="nc" id="L103">                        mismatchDescription.appendText(&quot;... and &quot; + remaining + &quot;more&quot;);</span>
<span class="nc" id="L104">                        break;</span>
                    }
<span class="nc" id="L106">                    mismatchDescription.appendText(mismatch);</span>
<span class="nc" id="L107">                    ++i;</span>
<span class="nc" id="L108">                }</span>
<span class="nc" id="L109">                mismatchDescription.appendText(&quot;\n     ]&quot;);</span>
            }
        }
<span class="nc" id="L112">    }</span>

    private static &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt;
    void collectMismatches(String xPath, T expected, T actual, LinkedList&lt;String&gt; mismatches) {
        // This is pretty heavy calculation, but since it's only done on
        // mismatch / test failure, it should be fine.
<span class="nc" id="L118">        if (expected.descriptor()</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">                    .getVariant() == PMessageVariant.UNION) {</span>
<span class="nc" id="L120">            PUnion&lt;?,?&gt; eu = (PUnion) expected;</span>
<span class="nc" id="L121">            PUnion&lt;?,?&gt; ac = (PUnion) actual;</span>

<span class="nc" id="L123">            if (!eu.unionField()</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">                   .equals(ac.unionField())) {</span>
<span class="nc" id="L125">                mismatches.add(String.format(&quot;%s to have %s, but had %s&quot;,</span>
                                             xPath,
<span class="nc" id="L127">                                             eu.unionField()</span>
<span class="nc" id="L128">                                               .getName(),</span>
<span class="nc" id="L129">                                             ac.unionField()</span>
<span class="nc" id="L130">                                               .getName()));</span>
            }
        }

<span class="nc bnc" id="L134" title="All 2 branches missed.">        for (PField field : expected.descriptor()</span>
<span class="nc" id="L135">                                       .getFields()) {</span>
<span class="nc" id="L136">            int key = field.getKey();</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">            String fieldXPath = xPath.isEmpty() ? field.getName() : xPath + &quot;.&quot; + field.getName();</span>

<span class="nc bnc" id="L139" title="All 2 branches missed.">            if (expected.has(key) != actual.has(key)) {</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                if (!expected.has(key)) {</span>
<span class="nc" id="L141">                    mismatches.add(String.format(&quot;%s to be missing, but was %s&quot;,</span>
                                                 fieldXPath,
<span class="nc" id="L143">                                                 toString(actual.get(field.getKey()))));</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">                } else if (!actual.has(key)) {</span>
<span class="nc" id="L145">                    mismatches.add(String.format(&quot;%s to be %s, but was missing&quot;,</span>
                                                 fieldXPath,
<span class="nc" id="L147">                                                 toString(expected.get(field.getKey()))));</span>
                }
<span class="nc bnc" id="L149" title="All 2 branches missed.">            } else if (!Objects.equals(expected.get(key), actual.get(key))) {</span>
<span class="nc bnc" id="L150" title="All 5 branches missed.">                switch (field.getType()) {</span>
                    case MESSAGE: {
<span class="nc" id="L152">                        collectMismatches(fieldXPath,</span>
<span class="nc" id="L153">                                          (PMessage) expected.get(key),</span>
<span class="nc" id="L154">                                          (PMessage) actual.get(key),</span>
                                          mismatches);
<span class="nc" id="L156">                        break;</span>
                    }
                    case LIST: {
<span class="nc" id="L159">                        collectListMismatches(fieldXPath, (List) expected.get(key), (List) actual.get(key), mismatches);</span>
<span class="nc" id="L160">                        break;</span>
                    }
                    case SET: {
<span class="nc" id="L163">                        collectSetMismatches(fieldXPath, (Set) expected.get(key), (Set) actual.get(key), mismatches);</span>
<span class="nc" id="L164">                        break;</span>
                    }
                    case MAP: {
<span class="nc" id="L167">                        collectMapMismatches(fieldXPath, (Map) expected.get(key), (Map) actual.get(key), mismatches);</span>
<span class="nc" id="L168">                        break;</span>
                    }
                    default: {
<span class="nc" id="L171">                        mismatches.add(String.format(&quot;%s was %s, expected %s&quot;,</span>
                                                     fieldXPath,
<span class="nc" id="L173">                                                     toString(actual.get(field.getKey())),</span>
<span class="nc" id="L174">                                                     toString(expected.get(field.getKey()))));</span>
                        break;
                    }
                }
            }
        }
<span class="nc" id="L180">    }</span>

    private static &lt;K, V&gt; void collectMapMismatches(String xPath,
                                                    Map&lt;K, V&gt; expected,
                                                    Map&lt;K, V&gt; actual,
                                                    LinkedList&lt;String&gt; mismatches) {
<span class="nc" id="L186">        mismatches.addAll(actual.keySet()</span>
<span class="nc" id="L187">                                .stream()</span>
<span class="nc" id="L188">                                .filter(key -&gt; !expected.keySet()</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                                                        .contains(key))</span>
<span class="nc" id="L190">                                .map(key -&gt; String.format(&quot;found unexpected entry (%s, %s) in %s&quot;,</span>
<span class="nc" id="L191">                                                          toString(key),</span>
<span class="nc" id="L192">                                                          toString(actual.get(key)),</span>
                                                          xPath))
<span class="nc" id="L194">                                .collect(Collectors.toList()));</span>

<span class="nc bnc" id="L196" title="All 2 branches missed.">        for (Map.Entry&lt;K,V&gt; entry : expected.entrySet()) {</span>
<span class="nc" id="L197">            if (!actual.keySet()</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">                       .contains(entry.getKey())) {</span>
<span class="nc" id="L199">                mismatches.add(String.format(&quot;did not find entry (%s, %s) in in %s&quot;,</span>
<span class="nc" id="L200">                                             toString(entry.getKey()),</span>
<span class="nc" id="L201">                                             toString(expected.get(entry.getKey())),</span>
                                             xPath));
            } else {
<span class="nc" id="L204">                V exp = entry.getValue();</span>
<span class="nc" id="L205">                V act = actual.get(entry.getKey());</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">                if (!Objects.equals(exp, act)) {</span>
                    // value differs.
<span class="nc" id="L208">                    String keyedXPath = String.format(&quot;%s[%s]&quot;, xPath, toString(entry));</span>
<span class="nc bnc" id="L209" title="All 4 branches missed.">                    if (exp == null || act == null) {</span>
<span class="nc" id="L210">                        mismatches.add(String.format(&quot;%s was %s, should be %s&quot;,</span>
                                                     keyedXPath,
<span class="nc" id="L212">                                                     toString(exp),</span>
<span class="nc" id="L213">                                                     toString(act)));</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                    } else if (act instanceof PMessage) {</span>
<span class="nc" id="L215">                        collectMismatches(keyedXPath, (PMessage) exp, (PMessage) act, mismatches);</span>
                    } else {
<span class="nc" id="L217">                        mismatches.add(String.format(&quot;%s was %s, should be %s&quot;,</span>
                                                     keyedXPath,
<span class="nc" id="L219">                                                     toString(act),</span>
<span class="nc" id="L220">                                                     toString(exp)));</span>
                    }
                }
            }
<span class="nc" id="L224">        }</span>
<span class="nc" id="L225">    }</span>

    private static &lt;T&gt; void collectSetMismatches(String xPath,
                                                 Set&lt;T&gt; expected,
                                                 Set&lt;T&gt; actual,
                                                 LinkedList&lt;String&gt; mismatches) {
        // order does NOT matter regardless of type. The only
        // errors are missing and unexpected values. Partial
        // matches are not checked.
<span class="nc" id="L234">        mismatches.addAll(actual.stream()</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">                                .filter(item -&gt; !expected.contains(item))</span>
<span class="nc" id="L236">                                .map(item -&gt; String.format(&quot;found unexpected set value %s in %s&quot;,</span>
<span class="nc" id="L237">                                                           toString(item),</span>
                                                           xPath))
<span class="nc" id="L239">                                .collect(Collectors.toList()));</span>

<span class="nc" id="L241">        mismatches.addAll(expected.stream()</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                                  .filter(item -&gt; !actual.contains(item))</span>
<span class="nc" id="L243">                                  .map(item -&gt; String.format(&quot;did not find value %s in %s&quot;, toString(item), xPath))</span>
<span class="nc" id="L244">                                  .collect(Collectors.toList()));</span>

<span class="nc" id="L246">    }</span>

    private static &lt;T&gt; void collectListMismatches(String xPath,
                                                  List&lt;T&gt; expected,
                                                  List&lt;T&gt; actual,
                                                  LinkedList&lt;String&gt; mismatches) {
<span class="nc" id="L252">        Set&lt;T&gt; handledItems = new HashSet&lt;&gt;();</span>

<span class="nc" id="L254">        boolean hasReorder = false;</span>
<span class="nc" id="L255">        LinkedList&lt;String&gt; reordering = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">        for (int expectedIndex = 0; expectedIndex &lt; expected.size(); ++expectedIndex) {</span>
<span class="nc" id="L257">            String indexedXPath = String.format(&quot;%s[%d]&quot;, xPath, expectedIndex);</span>
<span class="nc" id="L258">            T expectedItem = expected.get(expectedIndex);</span>
<span class="nc" id="L259">            handledItems.add(expectedItem);</span>

<span class="nc bnc" id="L261" title="All 2 branches missed.">            T actualItem = actual.size() &gt; expectedIndex ? actual.get(expectedIndex) : null;</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">            if (Objects.equals(expectedItem, actualItem)) {</span>
<span class="nc" id="L263">                continue;</span>
            }
<span class="nc" id="L265">            int actualIndex = actual.indexOf(expectedItem);</span>

<span class="nc" id="L267">            int actualItemExpectedIndex = -1;</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            if (actualItem != null) {</span>
<span class="nc" id="L269">                actualItemExpectedIndex = expected.indexOf(actualItem);</span>
            }

<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (actualIndex &lt; 0) {</span>
<span class="nc" id="L273">                reordering.add(&quot;NaN&quot;);</span>
                // this item is missing.
<span class="nc bnc" id="L275" title="All 2 branches missed.">                if (actualItemExpectedIndex &lt; 0) {</span>
<span class="nc" id="L276">                    handledItems.add(actualItem);</span>
                    // replaced with new item, diff them normally.
<span class="nc bnc" id="L278" title="All 2 branches missed.">                    if (actualItem instanceof PMessage) {</span>
<span class="nc" id="L279">                        collectMismatches(indexedXPath, (PMessage) expectedItem, (PMessage) actualItem, mismatches);</span>
                    } else {
<span class="nc" id="L281">                        mismatches.add(String.format(&quot;expected %s to be %s, but was %s&quot;,</span>
                                                     indexedXPath,
<span class="nc" id="L283">                                                     toString(expectedItem),</span>
<span class="nc" id="L284">                                                     toString(actualItem)));</span>
                    }
                } else {
                    // the other item is reordered, so this is blindly inserted.
<span class="nc" id="L288">                    mismatches.add(String.format(&quot;missing item %s in %s&quot;, toString(expectedItem), indexedXPath));</span>
                }
<span class="nc bnc" id="L290" title="All 2 branches missed.">            } else if (actualIndex != expectedIndex) {</span>
<span class="nc" id="L291">                reordering.add(String.format(&quot;%+d&quot;, actualIndex - expectedIndex));</span>
<span class="nc" id="L292">                hasReorder = true;</span>
            } else {
<span class="nc" id="L294">                reordering.add(&quot;Â±0&quot;);</span>
            }
        }
<span class="nc bnc" id="L297" title="All 2 branches missed.">        for (int actualIndex = 0; actualIndex &lt; actual.size(); ++actualIndex) {</span>
<span class="nc" id="L298">            T actualItem = actual.get(actualIndex);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">            if (handledItems.contains(actualItem)) {</span>
<span class="nc" id="L300">                continue;</span>
            }
<span class="nc bnc" id="L302" title="All 2 branches missed.">            if (expected.contains(actualItem)) {</span>
<span class="nc" id="L303">                continue;</span>
            }
<span class="nc" id="L305">            String indexedXPath = String.format(&quot;%s[%d]&quot;, xPath, actualIndex);</span>
<span class="nc" id="L306">            mismatches.add(String.format(&quot;unexpected item %s in %s&quot;, toString(actualItem), indexedXPath));</span>
        }
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (hasReorder) {</span>
<span class="nc" id="L309">            mismatches.add(String.format(&quot;unexpected item ordering in %s: [%s]&quot;, xPath, Strings.join(&quot;,&quot;, reordering)));</span>
        }

<span class="nc" id="L312">    }</span>

    protected static String toString(Object o) {
<span class="nc bnc" id="L315" title="All 2 branches missed.">        if (o == null) {</span>
<span class="nc" id="L316">            return &quot;null&quot;;</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">        } else if (o instanceof PMessage) {</span>
<span class="nc" id="L318">            return limitToString((PMessage) o);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        } else if (o instanceof PEnumValue) {</span>
<span class="nc" id="L320">            return ((PEnumValue) o).descriptor()</span>
<span class="nc" id="L321">                                   .getName() + &quot;.&quot; + ((PEnumValue) o).getName();</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        } else if (o instanceof Map) {</span>
<span class="nc" id="L323">            return &quot;{&quot; + Strings.join(&quot;,&quot;,</span>
<span class="nc" id="L324">                                      ((Map&lt;?, ?&gt;) o).entrySet()</span>
<span class="nc" id="L325">                                                     .stream()</span>
<span class="nc" id="L326">                                                     .map(e -&gt; toString(e.getKey()) + &quot;:&quot; + toString(e.getValue()))</span>
<span class="nc" id="L327">                                                     .collect(Collectors.toList())) + &quot;}&quot;;</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        } else if (o instanceof Collection) {</span>
<span class="nc" id="L329">            return &quot;[&quot; + Strings.join(&quot;,&quot;,</span>
<span class="nc" id="L330">                                      ((Collection&lt;?&gt;) o).stream()</span>
<span class="nc" id="L331">                                                         .map(EqualToMessage::toString)</span>
<span class="nc" id="L332">                                                         .collect(Collectors.toList())) + &quot;]&quot;;</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        } else if (o instanceof CharSequence) {</span>
<span class="nc" id="L334">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L335">            JsonWriter writer = new JsonWriter(baos);</span>
            try {
<span class="nc" id="L337">                writer.value((CharSequence) o);</span>
<span class="nc" id="L338">                writer.flush();</span>
<span class="nc" id="L339">                return new String(baos.toByteArray(), UTF_8);</span>
<span class="nc" id="L340">            } catch (JsonException e) {</span>
<span class="nc" id="L341">                return &quot;\&quot;&quot; + o.toString() + &quot;\&quot;&quot;;</span>
            }
<span class="nc bnc" id="L343" title="All 2 branches missed.">        } else if (o instanceof Binary) {</span>
<span class="nc" id="L344">            int len = ((Binary) o).length();</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">            if (len &gt; 110) {</span>
<span class="nc" id="L346">                return String.format(&quot;binary[%s...+%d]&quot;,</span>
<span class="nc" id="L347">                                     ((Binary) o).toHexString()</span>
<span class="nc" id="L348">                                                 .substring(0, 100),</span>
<span class="nc" id="L349">                                     len - 50);</span>
            } else {
<span class="nc" id="L351">                return &quot;binary[&quot; + ((Binary) o).toHexString() + &quot;]&quot;;</span>
            }
<span class="nc bnc" id="L353" title="All 2 branches missed.">        } else if (o instanceof Double) {</span>
<span class="nc" id="L354">            long l = ((Double) o).longValue();</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">            if (o.equals((double) l)) {</span>
<span class="nc" id="L356">                return Long.toString(l);</span>
            } else {
<span class="nc" id="L358">                return o.toString();</span>
            }
        } else {
<span class="nc" id="L361">            return o.toString();</span>
        }
    }

    private static String limitToString(PMessage&lt;?, ?&gt; message) {
<span class="nc bnc" id="L366" title="All 2 branches missed.">        String tos = message == null ? &quot;null&quot; : message.asString();</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (tos.length() &gt; 120) {</span>
<span class="nc" id="L368">            tos = tos.substring(0, 110) + &quot;...}&quot;;</span>
        }

<span class="nc" id="L371">        return tos;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>